<!doctype html>
<head>
  <meta charset="utf-8">
  <title>Overture benchmark</title>
  <script src="../overture.js"></script>
  <script src="compare/acorn.js"></script>
  <script src="compare/esprima.js"></script>
  <script src="jquery-string.js"></script>
  <script src="codemirror-string.js"></script>
  <script src="threejs-string.js"></script>
  <style>
    td { text-align: right; padding-right: 20px; }
    th { text-align: left; padding-right: 40px; }
    body { max-width: 50em; padding: 1em 2em; }
    h1 { font-size: 150%; }
  </style>
</head>

<h1>Overture/Acorn/Esprima speed comparison</h1>

<p>This will run each of the three parsers on the source code of
jQuery 1.6.4, CodeMirror 3.0b1 and threejs r51 for two seconds, and show a table
indicating the number of lines parsed per second. Note that UglifyJS
always stores location data, and is thus not fairly compared by the
benchmark <em>without</em> location data.<p>

<p>Also note that having the developer tools open in Chrome, or
Firebug in Firefox <em>heavily</em> influences the numbers you get. In
Chrome, the effect even lingers (in the tab) after you close the
developer tools. Load in a fresh tab to get (halfway) stable
numbers.</p>

<button onclick="run(false)">Compare <strong>without</strong> location data</button>
<button onclick="run(true)">Compare <strong>with</strong> location data</button>
<button onclick="run(false, true)">Run only Overture</button>
<span id="running"></span>

<script>
  var testStrings = [
    jquery164,
    codemirror30
    // ,
    // threejs51
  ];

  var runProfile = /[?&]profile(&|$)/.test(document.location.search);

  function runOverture(code, locations) {
    overture.parse(code, {locations: locations});
  }
  function runAcorn(code, locations) {
    acorn.parse(code, {locations: locations});
  }
  function runEsprima(code, locations) {
    esprima.parse(code, {loc: locations});
  }

  var i, totalLines = 0;
  for(i=0;i<testStrings.length;i++) {
    totalLines += testStrings[i].split('\n').length;
  }

  function benchmark(runner, locations) {
    // Give it a chance to warm up (first runs are usually outliers)
    for(i=0;i<testStrings.length;i++) {
      runner(testStrings[i], locations);
    }
    var t0 = +new Date, t1, lines = 0;
    if(runProfile) {console.profile();}
    for (;;) {
      for(i=0;i<testStrings.length;i++) {
        runner(testStrings[i], locations);
      }
      lines += totalLines;
      t1 = +new Date;
      if (t1 - t0 > 2000) break;
    }
    if(runProfile) {console.profileEnd();}
    return lines / ((t1 - t0) / 1000);
  }

  function showOutput(values) {
    var html = "<hr><table>";
    for (var i = 0; i < values.length; ++i)
      html += "<tr><th>" + values[i].name + "</td><td>" + Math.round(values[i].score) + " lines per second</td><td>" +
                        Math.round(values[i].score * 100 / values[0].score) + "%</td></tr>";
    document.body.appendChild(document.createElement("div")).innerHTML = html;
  }

  function run(locations, overtureOnly) {
    var running = document.getElementById("running");
    running.innerHTML = "Running benchmark...";
    var data = [
      {name: "Overture", runner: runOverture},
      {name: "Acorn", runner: runAcorn},
      {name: "Esprima", runner: runEsprima}
    ];
    if (overtureOnly) data.length = 1;
    var pos = 0;
    function next() {
      data[pos].score = benchmark(data[pos].runner, locations);
      if (++pos == data.length) {
        running.innerHTML = "";
        showOutput(data);
      } else setTimeout(next, 100);
    }
    setTimeout(next, 50);
  }
</script>
