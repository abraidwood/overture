<!DOCTYPE html>

<html>
<head>
  <title>overture.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="public/stylesheets/normalize.css" />
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div class="container">
    <div class="page">

      <div class="header">
        
          <h1>overture.js</h1>
        

        
      </div>

      
        
        <p>Overture is a fast JavaScript parser written in JavaScript.</p>
<p>Overture was written by Alistair Braidwood and released under an MIT
license. The Unicode regexps (for identifiers and whitespace) were
taken from <a href="http://esprima.org">Esprima</a> by Ariya Hidayat.</p>
<p>Git repositories for Overture are available at</p>
<pre><code>    https://github.com/abraidwood/overture.git</code></pre>
<p>Please use the <a href="https://github.com/abraidwood/overture/issues">github bug tracker</a> to report issues.</p>
<p>Overture owes a lot of its code structure and initial work to
Acorn:</p>
<p>Acorn was written by Marijn Haverbeke and released under an MIT
license. The Unicode regexps (for identifiers and whitespace) were
taken from <a href="http://esprima.org">Esprima</a> by Ariya Hidayat.</p>
<p>Git repositories for Acorn are available at</p>
<pre><code>    http://marijnhaverbeke.nl/git/acorn
    https://github.com/marijnh/acorn.git</code></pre>
<p>Please use the <a href="https://github.com/abraidwood/overture/issues">github bug tracker</a> to report issues.</p>

        
          <div class='highlight'><pre><span class="comment">/* jshint -W053, strict:true, eqeqeq:true, quotmark:single, undef:true, unused:true, trailing:true  */</span>
<span class="comment">/* global  exports, module, define, self */</span>

(<span class="keyword">function</span>(mod) {
    <span class="string">'use strict'</span>;
    <span class="keyword">if</span> (<span class="keyword">typeof</span>(exports) === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span>(module) === <span class="string">'object'</span>) {<span class="keyword">return</span> mod(exports);} <span class="comment">// CommonJS</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span>(define) === <span class="string">'function'</span> &amp;&amp; define.amd) {<span class="keyword">return</span> define([<span class="string">'exports'</span>], mod);} <span class="comment">// AMD</span>
    mod(self.overture || (self.overture = {})); <span class="comment">// Plain browser env</span>
})(<span class="keyword">function</span>(exports) {

    <span class="string">'use strict'</span>;

    exports.version = <span class="string">'0.1'</span>;</pre></div>
        
      
        
        <p>The main exported interface (under <code>self.overture</code> when in the
browser) is a <code>parse</code> function that takes a code string and
returns an abstract syntax tree as specified by <a href="https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API">Mozilla parser
API</a>, with the caveat that the SpiderMonkey-specific syntax
(<code>let</code>, <code>yield</code>, inline XML, etc) is not recognized.</p>

        
          <div class='highlight'><pre>    <span class="keyword">var</span> options, input, inputLen, sourceFile;

    exports.parse = <span class="keyword">function</span>(inpt, opts) {
        input = String(inpt);
        inputLen = input.length;
        options = opts || {};
        <span class="keyword">for</span> (<span class="keyword">var</span> opt <span class="keyword">in</span> defaultOptions) {
            <span class="keyword">if</span> (!options.hasOwnProperty(opt)) {
                options[opt] = defaultOptions[opt];
            }
        }
        sourceFile = options.sourceFile || <span class="literal">null</span>;

        <span class="keyword">if</span> (options.forbidReserved) {
            readWord = readWord_checkReserved;
        }

        <span class="keyword">return</span> parseTopLevel(options.program);
    };</pre></div>
        
      
        
        <p>A second optional argument can be given to further configure
the parser process. These options are recognized:</p>

        
          <div class='highlight'><pre>    <span class="keyword">var</span> defaultOptions = exports.defaultOptions = {</pre></div>
        
      
        
        <p><code>ecmaVersion</code> indicates the ECMAScript version to parse. Must
be either 3 or 5. This
influences support for strict mode, the set of reserved words, and
support for getters and setter.</p>

        
          <div class='highlight'><pre>        ecmaVersion: <span class="number">5</span>,</pre></div>
        
      
        
        <p>Turn on <code>strictSemicolons</code> to prevent the parser from doing
automatic semicolon insertion.</p>

        
          <div class='highlight'><pre>        strictSemicolons: <span class="literal">false</span>,</pre></div>
        
      
        
        <p>When <code>allowTrailingCommas</code> is false, the parser will not allow
trailing commas in array and object literals.</p>

        
          <div class='highlight'><pre>        allowTrailingCommas: <span class="literal">true</span>,</pre></div>
        
      
        
        <p>By default, reserved words are not enforced. Enable
<code>forbidReserved</code> to enforce them.</p>

        
          <div class='highlight'><pre>        forbidReserved: <span class="literal">false</span>,</pre></div>
        
      
        
        <p>When <code>locations</code> is on, <code>loc</code> properties holding objects with
<code>start</code> and <code>end</code> properties in <code>{line, column}</code> form (with
line being 1-based and column 0-based) will be attached to the
nodes.</p>

        
          <div class='highlight'><pre>        locations: <span class="literal">false</span>,</pre></div>
        
      
        
        <p>A function can be passed as <code>onComment</code> option, which will
cause Overture to call that function with <code>(block, text, start,
end)</code> parameters whenever a comment is skipped. <code>block</code> is a
boolean indicating whether this is a block (<code>/* */</code>) comment,
<code>text</code> is the content of the comment, and <code>start</code> and <code>end</code> are
character offsets that denote the start and end of the comment.
When the <code>locations</code> option is on, two more parameters are
passed, the full <code>{line, column}</code> locations of the start and
end of the comments.</p>

        
          <div class='highlight'><pre>        onComment: <span class="literal">null</span>,</pre></div>
        
      
        
        <p>Nodes have their start and end characters offsets recorded in
<code>start</code> and <code>end</code> properties (directly on the node, rather than
the <code>loc</code> object, which holds line/column data. To also add a
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=745678">semi-standardized</a> <code>range</code> property holding a <code>[start,
end]</code> array with the same numbers, set the <code>ranges</code> option to
<code>true</code>.</p>

        
          <div class='highlight'><pre>        ranges: <span class="literal">false</span>,</pre></div>
        
      
        
        <p>It is possible to parse multiple files into a single AST by
passing the tree produced by parsing the first file as
<code>program</code> option in subsequent parses. This will add the
toplevel forms of the parsed file to the <code>Program</code> (top) node
of an existing parse tree.</p>

        
          <div class='highlight'><pre>        program: <span class="literal">null</span>,</pre></div>
        
      
        
        <p>When <code>location</code> is on, you can pass this to record the source
file in every node&#39;s <code>loc</code> object.</p>

        
          <div class='highlight'><pre>        sourceFile: <span class="literal">null</span>
    };</pre></div>
        
      
        
        <p>The <code>getLineInfo</code> function is mostly useful when the
<code>locations</code> option is off (for performance reasons) and you
want to find the line/column position for a given character
offset. <code>input</code> should be the code string that the offset refers
into.</p>

        
          <div class='highlight'><pre>    <span class="keyword">var</span> getLineInfo = exports.getLineInfo = <span class="function"><span class="keyword">function</span> <span class="title">getLineInfo</span><span class="params">(input, offset)</span> {</span>
        <span class="keyword">for</span> (<span class="keyword">var</span> line = <span class="number">1</span>, cur = <span class="number">0</span>;;) {
            lineBreak.lastIndex = cur;
            <span class="keyword">var</span> match = lineBreak.exec(input);
            <span class="keyword">if</span> (match &amp;&amp; match.index &lt; offset) {
                ++line;
                cur = match.index + match[<span class="number">0</span>].length;
            } <span class="keyword">else</span> {
                <span class="keyword">break</span>;
            }
        }
        <span class="keyword">return</span> {
            line: line,
            column: offset - cur
        };
    };</pre></div>
        
      
        
        <p>Overture is organized as a tokenizer and a recursive-descent parser.
Both use (closure-)global variables to keep their state and
communicate. We already saw the <code>options</code>, <code>input</code>, and
<code>inputLen</code> variables above (set in <code>parse</code>).</p>
<p>The current position of the tokenizer in the input.</p>

        
          <div class='highlight'><pre>    <span class="keyword">var</span> tokPos = <span class="number">0</span>;</pre></div>
        
      
        
        <p>The start and end offsets of the current token.</p>

        
          <div class='highlight'><pre>    <span class="keyword">var</span> tokStart = <span class="number">0</span>, tokEnd = <span class="number">0</span>;</pre></div>
        
      
        
        <p>When <code>options.locations</code> is true, these hold objects
containing the tokens start and end line/column pairs.</p>

        
          <div class='highlight'><pre>    <span class="keyword">var</span> tokStartLoc, tokEndLoc;</pre></div>
        
      
        
        <p>The type and value of the current token. Token types are objects,
named by variables against which they can be compared, and
holding properties that describe them (indicating, for example,
the precedence of an infix operator, and the original name of a
keyword token). The kind of value that&#39;s held in <code>tokVal</code> depends
on the type of the token. For literals, it is the literal value,
for operators, the operator name, and so on.</p>

        
          <div class='highlight'><pre>    <span class="keyword">var</span> tokType = <span class="literal">null</span>, tokVal;</pre></div>
        
      
        
        <p>Interal state for the tokenizer. To distinguish between division
operators and regular expressions, it remembers whether the last
token was one that is allowed to be followed by an expression.
(If it is, a slash is probably a regexp, if it isn&#39;t it&#39;s a
division operator. See the <code>parseStatement</code> function for a
caveat.)</p>

        
          <div class='highlight'><pre>    <span class="keyword">var</span> tokRegexpAllowed;</pre></div>
        
      
        
        <p>These store the position of the previous token, which is useful
when finishing a node and assigning its <code>end</code> position.</p>

        
          <div class='highlight'><pre>    <span class="keyword">var</span> lastStart = <span class="number">0</span>, lastEnd = <span class="number">0</span>, lastEndLoc;</pre></div>
        
      
        
        <p>This is the parser&#39;s state. <code>inFunction</code> is used to reject
<code>return</code> statements outside of functions, <code>labels</code> to verify that
<code>break</code> and <code>continue</code> have somewhere to jump to, and <code>strict</code>
indicates whether strict mode is on.</p>

        
          <div class='highlight'><pre>    <span class="keyword">var</span> inFunction, labels, strict;</pre></div>
        
      
        
        <p>This function is used to raise exceptions on parse errors. It
takes either a <code>{line, column}</code> object or an offset integer (into
the current <code>input</code>) as <code>pos</code> argument. It attaches the position
to the end of the error message, and then raises a <code>SyntaxError</code>
with that message.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">raise</span><span class="params">(pos, message)</span> {</span>
        pos = pos || tokPos;
        <span class="keyword">if</span> (<span class="keyword">typeof</span>(pos) === <span class="string">'number'</span>) {
            pos = getLineInfo(input, pos);
        }
        message += <span class="string">' ('</span> + pos.line + <span class="string">':'</span> + pos.column + <span class="string">')'</span>;
        <span class="keyword">throw</span> <span class="keyword">new</span> SyntaxError(message);
    }</pre></div>
        
      
        
        <h2>Token types</h2>
<p>The assignment of fine-grained, information-carrying type objects
allows the tokenizer to store the information it has about a
token in a way that is very cheap for the parser to look up.</p>
<p>All token type variables start with an underscore, to make them
easy to recognize.</p>
<p>These are the general types. The <code>type</code> property is only used to
make them recognizeable when debugging.</p>
<p>By default, Reflect.parse() produces Node objects, which are plain JavaScript objects (i.e., their prototype derives from the standard Object prototype). All node types implement the following interface:</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">Node</span><span class="params">(type)</span> {</span>
        <span class="keyword">this</span>.type = type || <span class="literal">null</span>;   <span class="comment">// 'string'</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;            <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>The type field is a string representing the AST variant type. Each subtype of Node is documented below with the specific string of its type field. You can use this field to determine which interface a node implements.</p>
<p>The loc field represents the source location information of the node. If the parser produced no information about the node&#39;s source location, the field is null; otherwise it is an object consisting of a start position (the position of the first character of the parsed source region) and an end position (the position of the first character after the parsed source region):</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">SourceLocation</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.start = tokStartLoc;           <span class="comment">// Position</span>
        <span class="keyword">this</span>.end = <span class="literal">null</span>;                    <span class="comment">// Position</span>
        <span class="keyword">if</span> (sourceFile !== <span class="literal">null</span>) {
            <span class="keyword">this</span>.source = sourceFile;       <span class="comment">// string | null</span>
        }
    }</pre></div>
        
      
        
        <p>Each Position object consists of a line number (1-indexed) and a column number (0-indexed):</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">Position</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.line = <span class="number">1</span>;                      <span class="comment">// number &gt;= 1</span>
        <span class="keyword">this</span>.column = <span class="number">0</span>;                    <span class="comment">// number &gt;= 0</span>
    }</pre></div>
        
      
        
        <p>An identifier. Note that an identifier may be an expression or a destructuring pattern.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">Identifier</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'Identifier'</span>;
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
        <span class="keyword">this</span>.name = <span class="literal">null</span>;                   <span class="comment">// string</span>
    }</pre></div>
        
      
        
        <p>A complete program source tree.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">Program</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'Program'</span>;
        <span class="keyword">this</span>.body = [];                     <span class="comment">// [ Statement ]</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>A break statement.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">BreakStatement</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'BreakStatement'</span>;
        <span class="keyword">this</span>.label = <span class="literal">null</span>;                  <span class="comment">// Identifier | null</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>A continue statement.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">ContinueStatement</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'ContinueStatement'</span>;
        <span class="keyword">this</span>.label = <span class="literal">null</span>;                  <span class="comment">// Identifier | null</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>A debugger statement.
Note: The debugger statement is new in ECMAScript 5th edition, although SpiderMonkey has supported it for years.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">DebuggerStatement</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'DebuggerStatement'</span>;
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>A while statement.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">DoWhileStatement</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'DoWhileStatement'</span>;
        <span class="keyword">this</span>.body = <span class="literal">null</span>;                   <span class="comment">// Statement</span>
        <span class="keyword">this</span>.test = <span class="literal">null</span>;                   <span class="comment">// Expression</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>An if statement.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">IfStatement</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'IfStatement'</span>;
        <span class="keyword">this</span>.test = <span class="literal">null</span>;                   <span class="comment">// Expression</span>
        <span class="keyword">this</span>.consequent = <span class="literal">null</span>;             <span class="comment">// Statement</span>
        <span class="keyword">this</span>.alternate = <span class="literal">null</span>;              <span class="comment">// Statement | null</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>A return statement.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">ReturnStatement</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'ReturnStatement'</span>;
        <span class="keyword">this</span>.argument = <span class="literal">null</span>;               <span class="comment">// Expression | null</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>A switch statement. The lexical flag is metadata indicating whether the switch statement contains any unnested let declarations (and therefore introduces a new lexical scope).</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">SwitchStatement</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'SwitchStatement'</span>;
        <span class="keyword">this</span>.discriminant = <span class="literal">null</span>;           <span class="comment">// Expression</span>
        <span class="keyword">this</span>.cases = [];                    <span class="comment">// [ SwitchCase ]</span>
        <span class="keyword">this</span>.lexical = <span class="literal">false</span>;               <span class="comment">// boolean</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>A case (if test is an Expression) or default (if test === null) clause in the body of a switch statement.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">SwitchCase</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'SwitchCase'</span>;
        <span class="keyword">this</span>.test = <span class="literal">null</span>;                   <span class="comment">// Expression | null</span>
        <span class="keyword">this</span>.consequent = [];               <span class="comment">// [ Statement ]</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>A throw statement.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">ThrowStatement</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'ThrowStatement'</span>;
        <span class="keyword">this</span>.argument = <span class="literal">null</span>;               <span class="comment">// Expression</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>A try statement.
Note: Multiple catch clauses are SpiderMonkey-specific. (and not implemented in overture)</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">TryStatement</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'TryStatement'</span>;
        <span class="keyword">this</span>.block = <span class="literal">null</span>;                  <span class="comment">// BlockStatement</span>
        <span class="keyword">this</span>.handler = <span class="literal">null</span>;                <span class="comment">// CatchClause | null</span></pre></div>
        
      
        
        <p>this.guardedHandlers = [];        // [ CatchClause ]</p>

        
          <div class='highlight'><pre>        <span class="keyword">this</span>.finalizer = <span class="literal">null</span>;              <span class="comment">// BlockStatement | null</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>A catch clause following a try block. The optional guard property corresponds to the optional expression guard on the bound variable.
Note: The guard expression is SpiderMonkey-specific. (and not implemented in overture)</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">CatchClause</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'CatchClause'</span>;
        <span class="keyword">this</span>.param = <span class="literal">null</span>;                  <span class="comment">// Pattern</span></pre></div>
        
      
        
        <p>this.guard = null;                // Expression | null</p>

        
          <div class='highlight'><pre>        <span class="keyword">this</span>.body = <span class="literal">null</span>;                   <span class="comment">// BlockStatement</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }

    <span class="function"><span class="keyword">function</span> <span class="title">WhileStatement</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'WhileStatement'</span>;
        <span class="keyword">this</span>.body = <span class="literal">null</span>;                   <span class="comment">// Statement</span>
        <span class="keyword">this</span>.test = <span class="literal">null</span>;                   <span class="comment">// Expression</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>A with statement.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">WithStatement</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'WithStatement'</span>;
        <span class="keyword">this</span>.object = <span class="literal">null</span>;                 <span class="comment">// Expression</span>
        <span class="keyword">this</span>.body = <span class="literal">null</span>;                   <span class="comment">// Statement</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>An empty statement, i.e., a solitary semicolon.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">EmptyStatement</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'EmptyStatement'</span>;
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>A labeled statement, i.e., a statement prefixed by a break/continue label.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">LabeledStatement</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'LabeledStatement'</span>;
        <span class="keyword">this</span>.label = <span class="literal">null</span>;                  <span class="comment">// Identifier</span>
        <span class="keyword">this</span>.body = <span class="literal">null</span>;                   <span class="comment">// Statement</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>An expression statement, i.e., a statement consisting of a single expression.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">ExpressionStatement</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'ExpressionStatement'</span>;
        <span class="keyword">this</span>.expression = <span class="literal">null</span>;             <span class="comment">// Expression</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>A block statement, i.e., a sequence of statements surrounded by braces.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">BlockStatement</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'BlockStatement'</span>;
        <span class="keyword">this</span>.body = [];                     <span class="comment">// [ Statement ]</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>A for statement.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">ForStatement</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'ForStatement'</span>;
        <span class="keyword">this</span>.init = <span class="literal">null</span>;                   <span class="comment">// VariableDeclaration | Expression | null</span>
        <span class="keyword">this</span>.test = <span class="literal">null</span>;                   <span class="comment">// Expression | null</span>
        <span class="keyword">this</span>.update = <span class="literal">null</span>;                 <span class="comment">// Expression | null</span>
        <span class="keyword">this</span>.body = <span class="literal">null</span>;                   <span class="comment">// Statement</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>A for/in statement, or, if each is true, a for each/in statement.
Note: The for each form is SpiderMonkey-specific. (and not implemented in overture)</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">ForInStatement</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'ForInStatement'</span>;
        <span class="keyword">this</span>.left = <span class="literal">null</span>;                   <span class="comment">// VariableDeclaration |  Expression</span>
        <span class="keyword">this</span>.right = <span class="literal">null</span>;                  <span class="comment">// Expression</span>
        <span class="keyword">this</span>.body = <span class="literal">null</span>;                   <span class="comment">// Statement</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>A variable declaration, via one of var, let, or const.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">VariableDeclaration</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'VariableDeclaration'</span>;
        <span class="keyword">this</span>.declarations = [];             <span class="comment">// [ VariableDeclarator ]</span>
        <span class="keyword">this</span>.kind = <span class="string">'var'</span>;                  <span class="comment">// "var" | "let" | "const"</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>A variable declarator.
Note: The id field cannot be null.
Note: let and const are SpiderMonkey-specific. (and not implemented in overture)</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">VariableDeclarator</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'VariableDeclarator'</span>;
        <span class="keyword">this</span>.id = <span class="literal">null</span>;                     <span class="comment">// Pattern</span>
        <span class="keyword">this</span>.init = <span class="literal">null</span>;                   <span class="comment">// Expression | null</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>A sequence expression, i.e., a comma-separated sequence of expressions.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">SequenceExpression</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'SequenceExpression'</span>;
        <span class="keyword">this</span>.expressions = [];              <span class="comment">// [ Expression ]</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>An assignment operator expression.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">AssignmentExpression</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'AssignmentExpression'</span>;
        <span class="keyword">this</span>.operator = <span class="literal">null</span>;               <span class="comment">// AssignmentOperator</span>
        <span class="keyword">this</span>.left = <span class="literal">null</span>;                   <span class="comment">// Expression</span>
        <span class="keyword">this</span>.right = <span class="literal">null</span>;                  <span class="comment">// Expression</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>A conditional expression, i.e., a ternary ?/: expression.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">ConditionalExpression</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'ConditionalExpression'</span>;
        <span class="keyword">this</span>.test = <span class="literal">null</span>;                   <span class="comment">// Expression</span>
        <span class="keyword">this</span>.consequent = <span class="literal">null</span>;             <span class="comment">// Expression</span>
        <span class="keyword">this</span>.alternate = <span class="literal">null</span>;              <span class="comment">// Expression</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>A logical operator expression.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">LogicalExpression</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'LogicalExpression'</span>;
        <span class="keyword">this</span>.operator = <span class="literal">null</span>;               <span class="comment">// LogicalOperator</span>
        <span class="keyword">this</span>.left = <span class="literal">null</span>;                   <span class="comment">// Expression</span>
        <span class="keyword">this</span>.right = <span class="literal">null</span>;                  <span class="comment">// Expression</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>A binary operator expression.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">BinaryExpression</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'BinaryExpression'</span>;
        <span class="keyword">this</span>.operator = <span class="literal">null</span>;               <span class="comment">// BinaryOperator</span>
        <span class="keyword">this</span>.left = <span class="literal">null</span>;                   <span class="comment">// Expression</span>
        <span class="keyword">this</span>.right = <span class="literal">null</span>;                  <span class="comment">// Expression</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>An update (increment or decrement) operator expression.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">UpdateExpression</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'UpdateExpression'</span>;
        <span class="keyword">this</span>.operator = <span class="literal">null</span>;               <span class="comment">// UpdateOperator</span>
        <span class="keyword">this</span>.argument = <span class="literal">null</span>;               <span class="comment">// Expression</span>
        <span class="keyword">this</span>.prefix = <span class="literal">true</span>;                 <span class="comment">// boolean</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>A unary operator expression.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">UnaryExpression</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'UnaryExpression'</span>;
        <span class="keyword">this</span>.operator = <span class="literal">null</span>;               <span class="comment">// UnaryOperator</span>
        <span class="keyword">this</span>.argument = <span class="literal">null</span>;               <span class="comment">// Expression</span>
        <span class="keyword">this</span>.prefix = <span class="literal">true</span>;                 <span class="comment">// boolean</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>A member expression. If computed === true, the node corresponds to a computed e1[e2] expression and property is an Expression. If computed === false, the node corresponds to a static e1.x expression and property is an Identifier.
Note: &quot;_dot&quot; and &quot;_bracketL&quot; suffix is for overture performance</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">MemberExpression_dot</span><span class="params">(b)</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'MemberExpression'</span>;
        <span class="keyword">this</span>.object = b;                    <span class="comment">// Expression</span>
        <span class="keyword">this</span>.property = <span class="literal">null</span>;               <span class="comment">// Identifier | Expression</span>
        <span class="keyword">this</span>.computed = <span class="literal">false</span>;              <span class="comment">// boolean</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }
    <span class="function"><span class="keyword">function</span> <span class="title">MemberExpression_bracketL</span><span class="params">(b)</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'MemberExpression'</span>;
        <span class="keyword">this</span>.object = b;                    <span class="comment">// Expression</span>
        <span class="keyword">this</span>.property = <span class="literal">null</span>;               <span class="comment">// Identifier | Expression</span>
        <span class="keyword">this</span>.computed = <span class="literal">true</span>;               <span class="comment">// boolean</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>A function or method call expression.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">CallExpression</span><span class="params">(callee)</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'CallExpression'</span>;
        <span class="keyword">this</span>.callee = callee;               <span class="comment">// Expression</span>
        <span class="keyword">this</span>.arguments = [];                <span class="comment">// [ Expression | null ]</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>A this expression.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">ThisExpression</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'ThisExpression'</span>;
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>A literal token. Note that a literal can be an expression.
Note: &quot;_number&quot;, &quot;_string&quot;, &quot;_regexp&quot;, &quot;_null&quot;, &quot;_true&quot;, &quot;_false&quot; suffix is for overture performance</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">Literal_number</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'Literal'</span>;
        <span class="keyword">this</span>.value = <span class="number">0</span>;                     <span class="comment">// number</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }
    <span class="function"><span class="keyword">function</span> <span class="title">Literal_string</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'Literal'</span>;
        <span class="keyword">this</span>.value = <span class="string">''</span>;                    <span class="comment">// string</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }
    <span class="function"><span class="keyword">function</span> <span class="title">Literal_regexp</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'Literal'</span>;
        <span class="keyword">this</span>.value = <span class="literal">null</span>;                  <span class="comment">// regexp</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }
    <span class="function"><span class="keyword">function</span> <span class="title">Literal_null</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'Literal'</span>;
        <span class="keyword">this</span>.value = <span class="literal">null</span>;                  <span class="comment">// null</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }
    <span class="function"><span class="keyword">function</span> <span class="title">Literal_true</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'Literal'</span>;
        <span class="keyword">this</span>.value = <span class="literal">true</span>;                  <span class="comment">// true</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }
    <span class="function"><span class="keyword">function</span> <span class="title">Literal_false</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'Literal'</span>;
        <span class="keyword">this</span>.value = <span class="literal">false</span>;                 <span class="comment">// false</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>An array expression.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">ArrayExpression</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'ArrayExpression'</span>;
        <span class="keyword">this</span>.elements = [];                 <span class="comment">// [ Expression | null ]</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>A new expression.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">NewExpression</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'NewExpression'</span>;
        <span class="keyword">this</span>.callee = <span class="literal">null</span>;                 <span class="comment">// Expression</span>
        <span class="keyword">this</span>.arguments = [];                <span class="comment">// [ Expression | null ]</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>An object expression. A literal property in an object expression can have either a string or number as its value. Ordinary property initializers have a kind value &quot;init&quot;; getters and setters have the kind values &quot;get&quot; and &quot;set&quot;, respectively.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">ObjectExpression</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'ObjectExpression'</span>;
        <span class="keyword">this</span>.properties = [];               <span class="comment">// [ ObjectExpressionProp ]</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>Overture helper</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">ObjectExpressionProp</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.key = <span class="literal">null</span>;                    <span class="comment">// Literal | Identifier</span>
        <span class="keyword">this</span>.value = <span class="literal">null</span>;                  <span class="comment">// Expression</span>
        <span class="keyword">this</span>.kind = <span class="string">'init'</span>;                 <span class="comment">// "init" | "get" | "set"</span>
    }</pre></div>
        
      
        
        <p>A function declaration.
Note: The id field cannot be null.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">FunctionDeclaration</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'FunctionDeclaration'</span>;
        <span class="keyword">this</span>.id = <span class="literal">null</span>;                     <span class="comment">// Identifier</span>
        <span class="keyword">this</span>.params = [];                   <span class="comment">// [ Pattern ]</span>
        <span class="keyword">this</span>.defaults = [];                 <span class="comment">// [ Expression ]</span>
        <span class="keyword">this</span>.rest = <span class="literal">null</span>;                   <span class="comment">// Identifier | null</span>
        <span class="keyword">this</span>.body = <span class="literal">null</span>;                   <span class="comment">// BlockStatement | Expression</span>
        <span class="keyword">this</span>.expression = <span class="literal">false</span>;            <span class="comment">// boolean</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>A function expression.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">FunctionExpression</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.type = <span class="string">'FunctionExpression'</span>;
        <span class="keyword">this</span>.id = <span class="literal">null</span>;                     <span class="comment">// Identifier | null</span>
        <span class="keyword">this</span>.params = [];                   <span class="comment">// [ Pattern ]</span>
        <span class="keyword">this</span>.defaults = [];                 <span class="comment">// [ Expression ]</span>
        <span class="keyword">this</span>.rest = <span class="literal">null</span>;                   <span class="comment">// Identifier | null</span>
        <span class="keyword">this</span>.body = <span class="literal">null</span>;                   <span class="comment">// BlockStatement | Expression</span>
        <span class="keyword">this</span>.expression = <span class="literal">false</span>;            <span class="comment">// boolean</span>
        <span class="keyword">this</span>.loc = <span class="literal">null</span>;                    <span class="comment">// SourceLocation | null</span>
    }</pre></div>
        
      
        
        <p>Overture helper</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">Label</span><span class="params">(name)</span> {</span>
        <span class="keyword">this</span>.name = name;
        <span class="keyword">this</span>.kind = <span class="literal">null</span>;
    }

    <span class="keyword">var</span> PropertyKind = {
        <span class="string">'init'</span>: <span class="keyword">new</span> String(<span class="string">'init'</span>),
        <span class="string">'get'</span>: <span class="keyword">new</span> String(<span class="string">'get'</span>),
        <span class="string">'set'</span>: <span class="keyword">new</span> String(<span class="string">'set'</span>)
    };</pre></div>
        
      
        
        <p>Assignment operator tokens.</p>

        
          <div class='highlight'><pre>    <span class="keyword">var</span> AssignmentOperator = {
        <span class="string">'eq'</span>: <span class="keyword">new</span> String(<span class="string">'='</span>),
        <span class="string">'plus'</span>: <span class="keyword">new</span> String(<span class="string">'+='</span>),
        <span class="string">'minus'</span>: <span class="keyword">new</span> String(<span class="string">'-='</span>),
        <span class="string">'mult'</span>: <span class="keyword">new</span> String(<span class="string">'*='</span>),
        <span class="string">'div'</span>: <span class="keyword">new</span> String(<span class="string">'/='</span>),
        <span class="string">'modulo'</span>: <span class="keyword">new</span> String(<span class="string">'%='</span>),
        <span class="string">'left_shift'</span>: <span class="keyword">new</span> String(<span class="string">'&lt;&lt;='</span>),
        <span class="string">'right_shift'</span>: <span class="keyword">new</span> String(<span class="string">'&gt;&gt;='</span>),
        <span class="string">'zero_fill_right_shift'</span>: <span class="keyword">new</span> String(<span class="string">'&gt;&gt;&gt;='</span>),
        <span class="string">'OR'</span>: <span class="keyword">new</span> String(<span class="string">'|='</span>),
        <span class="string">'XOR'</span>: <span class="keyword">new</span> String(<span class="string">'^='</span>),
        <span class="string">'AND'</span>: <span class="keyword">new</span> String(<span class="string">'&amp;='</span>)
    };</pre></div>
        
      
        
        <p>Binary operator tokens.</p>

        
          <div class='highlight'><pre>    <span class="keyword">var</span> BinaryOperator = {
        <span class="string">'eq_eq'</span>: <span class="keyword">new</span> String(<span class="string">'=='</span>),
        <span class="string">'ex_eq'</span>: <span class="keyword">new</span> String(<span class="string">'!='</span>),
        <span class="string">'eq_eq_eq'</span>: <span class="keyword">new</span> String(<span class="string">'==='</span>),
        <span class="string">'ex_eq_eq'</span>: <span class="keyword">new</span> String(<span class="string">'!=='</span>),
        <span class="string">'lt'</span>: <span class="keyword">new</span> String(<span class="string">'&lt;'</span>),
        <span class="string">'lt_eq'</span>: <span class="keyword">new</span> String(<span class="string">'&lt;='</span>),
        <span class="string">'gt'</span>: <span class="keyword">new</span> String(<span class="string">'&gt;'</span>),
        <span class="string">'gt_eq'</span>: <span class="keyword">new</span> String(<span class="string">'&gt;='</span>),
        <span class="string">'left_shift'</span>: <span class="keyword">new</span> String(<span class="string">'&lt;&lt;'</span>),
        <span class="string">'right_shift'</span>: <span class="keyword">new</span> String(<span class="string">'&gt;&gt;'</span>),
        <span class="string">'zero_fill_right_shift'</span>: <span class="keyword">new</span> String(<span class="string">'&gt;&gt;&gt;'</span>),
        <span class="string">'plus'</span>: <span class="keyword">new</span> String(<span class="string">'+'</span>),
        <span class="string">'minus'</span>: <span class="keyword">new</span> String(<span class="string">'-'</span>),
        <span class="string">'mult'</span>: <span class="keyword">new</span> String(<span class="string">'*'</span>),
        <span class="string">'div'</span>: <span class="keyword">new</span> String(<span class="string">'/'</span>),
        <span class="string">'modulo'</span>: <span class="keyword">new</span> String(<span class="string">'%'</span>),
        <span class="string">'OR'</span>: <span class="keyword">new</span> String(<span class="string">'|'</span>),
        <span class="string">'AND'</span>: <span class="keyword">new</span> String(<span class="string">'&amp;'</span>),
        <span class="string">'XOR'</span>: <span class="keyword">new</span> String(<span class="string">'^'</span>),
        <span class="string">'in'</span>: <span class="keyword">new</span> String(<span class="string">'in'</span>),
        <span class="string">'instanceof'</span>: <span class="keyword">new</span> String(<span class="string">'instanceof'</span>)
    };</pre></div>
        
      
        
        <p>Logical operator tokens.</p>

        
          <div class='highlight'><pre>    <span class="keyword">var</span> LogicalOperator = {
        <span class="string">'OR'</span>: <span class="keyword">new</span> String(<span class="string">'||'</span>),
        <span class="string">'AND'</span>: <span class="keyword">new</span> String(<span class="string">'&amp;&amp;'</span>)
    };</pre></div>
        
      
        
        <p>Update opertator tokens.</p>

        
          <div class='highlight'><pre>    <span class="keyword">var</span> UpdateOperator = {
        <span class="string">'increment'</span>: <span class="keyword">new</span> String(<span class="string">'++'</span>),
        <span class="string">'decrement'</span>: <span class="keyword">new</span> String(<span class="string">'--'</span>)
    };</pre></div>
        
      
        
        <p>Unary operator tokens.</p>

        
          <div class='highlight'><pre>    <span class="keyword">var</span> UnaryOperator = {
        <span class="string">'minus'</span>: <span class="keyword">new</span> String(<span class="string">'-'</span>),
        <span class="string">'plus'</span>: <span class="keyword">new</span> String(<span class="string">'+'</span>),
        <span class="string">'ex'</span>: <span class="keyword">new</span> String(<span class="string">'!'</span>),
        <span class="string">'BITWISE_NOT'</span>: <span class="keyword">new</span> String(<span class="string">'~'</span>),
        <span class="string">'typeof'</span>: <span class="keyword">new</span> String(<span class="string">'typeof'</span>),
        <span class="string">'void'</span>: <span class="keyword">new</span> String(<span class="string">'void'</span>),
        <span class="string">'delete'</span>: <span class="keyword">new</span> String(<span class="string">'delete'</span>)
    };

    <span class="keyword">var</span> VariableDeclarationKind = {
        <span class="string">'var'</span>: <span class="keyword">new</span> String(<span class="string">'var'</span>),
        <span class="string">'let'</span>: <span class="keyword">new</span> String(<span class="string">'let'</span>),
        <span class="string">'const'</span>: <span class="keyword">new</span> String(<span class="string">'const'</span>)
    };

    <span class="keyword">var</span> _num = <span class="keyword">new</span> Node(<span class="string">'num'</span>),
        _regexp = <span class="keyword">new</span> Node(<span class="string">'regexp'</span>),
        _string = <span class="keyword">new</span> Node(<span class="string">'string'</span>),
        _name = <span class="keyword">new</span> Node(<span class="string">'name'</span>),
        _eof = <span class="keyword">new</span> Binop(<span class="number">0</span>);</pre></div>
        
      
        
        <p>Keyword tokens. The <code>keyword</code> property (also used in keyword-like
operators) indicates that the token originated from an
identifier-like word, which is used when parsing property names.</p>
<p>The <code>beforeExpr</code> property is used to disambiguate between regular
expressions and divisions. It is set on all token types that can
be followed by an expression (thus, a slash after them would be a
regular expression).</p>
<p><code>isLoop</code> marks a keyword as starting a loop, which is important
to know when parsing a label, in order to allow or disallow
continue jumps to that label.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">Keyword</span><span class="params">(word, params)</span> {</span>
        <span class="keyword">this</span>.keyword = <span class="keyword">new</span> String(word);
        <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> params) {
            <span class="keyword">if</span>(!params.hasOwnProperty(key)) {<span class="keyword">continue</span>;}
            <span class="keyword">this</span>[key] = params[key];
        }
    }

    <span class="function"><span class="keyword">function</span> <span class="title">Binop</span><span class="params">(precedence, params)</span> {</span>
        <span class="keyword">this</span>.precedence = precedence;
        <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> params) {
            <span class="keyword">if</span>(!params.hasOwnProperty(key)) {<span class="keyword">continue</span>;}
            <span class="keyword">this</span>[key] = params[key];
        }
    }

    <span class="keyword">var</span> _<span class="keyword">break</span> = <span class="keyword">new</span> Keyword(<span class="string">'break'</span>);
    <span class="keyword">var</span> _<span class="keyword">case</span> = <span class="keyword">new</span> Keyword(<span class="string">'case'</span>);
    <span class="keyword">var</span> _<span class="keyword">catch</span> = <span class="keyword">new</span> Keyword(<span class="string">'catch'</span>);
    <span class="keyword">var</span> _<span class="keyword">continue</span> = <span class="keyword">new</span> Keyword(<span class="string">'continue'</span>);
    <span class="keyword">var</span> _debugger = <span class="keyword">new</span> Keyword(<span class="string">'debugger'</span>);
    <span class="keyword">var</span> _<span class="keyword">default</span> = <span class="keyword">new</span> Keyword(<span class="string">'default'</span>);
    <span class="keyword">var</span> _<span class="keyword">do</span> = <span class="keyword">new</span> Keyword(<span class="string">'do'</span>, {isLoop:<span class="literal">true</span>});
    <span class="keyword">var</span> _<span class="keyword">else</span> = <span class="keyword">new</span> Keyword(<span class="string">'else'</span>);
    <span class="keyword">var</span> _<span class="literal">false</span> = <span class="keyword">new</span> Keyword(<span class="string">'false'</span>);
    <span class="keyword">var</span> _<span class="keyword">finally</span> = <span class="keyword">new</span> Keyword(<span class="string">'finally'</span>);
    <span class="keyword">var</span> _<span class="keyword">for</span> = <span class="keyword">new</span> Keyword(<span class="string">'for'</span>, {isLoop:<span class="literal">true</span>});
    <span class="keyword">var</span> _<span class="keyword">function</span> = <span class="keyword">new</span> Keyword(<span class="string">'function'</span>);
    <span class="keyword">var</span> _<span class="keyword">if</span> = <span class="keyword">new</span> Keyword(<span class="string">'if'</span>);
    <span class="keyword">var</span> _<span class="keyword">new</span> = <span class="keyword">new</span> Keyword(<span class="string">'new'</span>);
    <span class="keyword">var</span> _<span class="literal">null</span> = <span class="keyword">new</span> Keyword(<span class="string">'null'</span>);
    <span class="keyword">var</span> _<span class="keyword">return</span> = <span class="keyword">new</span> Keyword(<span class="string">'return'</span>);
    <span class="keyword">var</span> _<span class="keyword">switch</span> = <span class="keyword">new</span> Keyword(<span class="string">'switch'</span>);
    <span class="keyword">var</span> _<span class="keyword">this</span> = <span class="keyword">new</span> Keyword(<span class="string">'this'</span>);
    <span class="keyword">var</span> _<span class="keyword">throw</span> = <span class="keyword">new</span> Keyword(<span class="string">'throw'</span>);
    <span class="keyword">var</span> _<span class="literal">true</span> = <span class="keyword">new</span> Keyword(<span class="string">'true'</span>);
    <span class="keyword">var</span> _<span class="keyword">try</span> = <span class="keyword">new</span> Keyword(<span class="string">'try'</span>);
    <span class="keyword">var</span> _<span class="keyword">var</span> = <span class="keyword">new</span> Keyword(<span class="string">'var'</span>);
    <span class="keyword">var</span> _<span class="keyword">while</span> = <span class="keyword">new</span> Keyword(<span class="string">'while'</span>, {isLoop:<span class="literal">true</span>});
    <span class="keyword">var</span> _<span class="keyword">with</span> = <span class="keyword">new</span> Keyword(<span class="string">'with'</span>);</pre></div>
        
      
        
        <p>Some keywords are treated as regular operators. <code>in</code> sometimes
(when parsing <code>for</code>) needs to be tested against specifically, so
we assign a variable name to it for quick comparing.</p>

        
          <div class='highlight'><pre>    <span class="keyword">var</span> _<span class="keyword">in</span> = <span class="keyword">new</span> Binop(<span class="number">7</span>);
    <span class="keyword">var</span> _<span class="keyword">void</span> = <span class="keyword">new</span> Binop(<span class="number">0</span>, {prefix:<span class="literal">true</span>});
    <span class="keyword">var</span> _<span class="keyword">delete</span> = <span class="keyword">new</span> Binop(<span class="number">0</span>, {prefix:<span class="literal">true</span>});
    <span class="keyword">var</span> _<span class="keyword">typeof</span> = <span class="keyword">new</span> Binop(<span class="number">0</span>, {prefix:<span class="literal">true</span>});
    <span class="keyword">var</span> _<span class="keyword">instanceof</span> = <span class="keyword">new</span> Binop(<span class="number">7</span>);</pre></div>
        
      
        
        <p>Punctuation token types. Again, the <code>type</code> property is purely for debugging.</p>

        
          <div class='highlight'><pre>    <span class="keyword">var</span> _bracketL = <span class="keyword">new</span> Keyword(<span class="string">'['</span>);
    <span class="keyword">var</span> _bracketR = <span class="keyword">new</span> Keyword(<span class="string">']'</span>);
    <span class="keyword">var</span> _braceL = <span class="keyword">new</span> Keyword(<span class="string">'{'</span>);
    <span class="keyword">var</span> _braceR = <span class="keyword">new</span> Keyword(<span class="string">'}'</span>);
    <span class="keyword">var</span> _parenL = <span class="keyword">new</span> Keyword(<span class="string">'('</span>);
    <span class="keyword">var</span> _parenR = <span class="keyword">new</span> Keyword(<span class="string">')'</span>);
    <span class="keyword">var</span> _comma = <span class="keyword">new</span> Keyword(<span class="string">','</span>);
    <span class="keyword">var</span> _semi = <span class="keyword">new</span> Keyword(<span class="string">';'</span>);
    <span class="keyword">var</span> _colon = <span class="keyword">new</span> Keyword(<span class="string">':'</span>);
    <span class="keyword">var</span> _dot = <span class="keyword">new</span> Keyword(<span class="string">'.'</span>);
    <span class="keyword">var</span> _question = <span class="keyword">new</span> Keyword(<span class="string">'?'</span>);</pre></div>
        
      
        
        <p>Operators. These carry several kinds of properties to help the
parser use them properly (the presence of these properties is
what categorizes them as operators).</p>
<p><code>binop</code>, when present, specifies that this operator is a binary
operator, and will refer to its precedence.</p>
<p><code>prefix</code> and <code>postfix</code> mark the operator as a prefix or postfix
unary operator. <code>isUpdate</code> specifies that the node produced by
the operator should be of type UpdateExpression rather than
simply UnaryExpression (<code>++</code> and <code>--</code>).</p>
<p><code>isAssign</code> marks all of <code>=</code>, <code>+=</code>, <code>-=</code> etcetera, which act as
binary operators with a very low precedence, that should result
in AssignmentExpression nodes.</p>

        
          <div class='highlight'><pre>    <span class="keyword">var</span> _slash = <span class="keyword">new</span> Binop(<span class="number">10</span>);
    <span class="keyword">var</span> _eq = <span class="keyword">new</span> Binop(<span class="number">0</span>, {isAssign:<span class="literal">true</span>});
    <span class="keyword">var</span> _assign = <span class="keyword">new</span> Binop(<span class="number">0</span>, {isAssign:<span class="literal">true</span>});
    <span class="keyword">var</span> _plusmin = <span class="keyword">new</span> Binop(<span class="number">9</span>, {prefix:<span class="literal">true</span>});
    <span class="keyword">var</span> _incdec = <span class="keyword">new</span> Binop(<span class="number">0</span>, {prefix:<span class="literal">true</span>,postfix:<span class="literal">true</span>,isUpdate:<span class="literal">true</span>});
    <span class="keyword">var</span> _prefix = <span class="keyword">new</span> Binop(<span class="number">0</span>, {prefix:<span class="literal">true</span>});

    <span class="keyword">var</span> _bin_minop = <span class="keyword">new</span> Binop(<span class="number">0</span>);
    <span class="keyword">var</span> _bin1 = <span class="keyword">new</span> Binop(<span class="number">1</span>);
    <span class="keyword">var</span> _bin2 = <span class="keyword">new</span> Binop(<span class="number">2</span>);
    <span class="keyword">var</span> _bin3 = <span class="keyword">new</span> Binop(<span class="number">3</span>);
    <span class="keyword">var</span> _bin4 = <span class="keyword">new</span> Binop(<span class="number">4</span>);
    <span class="keyword">var</span> _bin5 = <span class="keyword">new</span> Binop(<span class="number">5</span>);
    <span class="keyword">var</span> _bin6 = <span class="keyword">new</span> Binop(<span class="number">6</span>);
    <span class="keyword">var</span> _bin7 = <span class="keyword">new</span> Binop(<span class="number">7</span>);
    <span class="keyword">var</span> _bin8 = <span class="keyword">new</span> Binop(<span class="number">8</span>);
    <span class="keyword">var</span> _bin10 = <span class="keyword">new</span> Binop(<span class="number">10</span>);</pre></div>
        
      
        
        <p>This is a trick taken from Esprima. It turns out that, on
non-Chrome browsers, to check whether a string is in a set, a
predicate containing a big ugly <code>switch</code> statement is faster than
a regular expression, and on Chrome the two are about on par.</p>
<p>eval was removed as it can&#39;t be optimized in v8 and the functions
are &#39;very hot&#39; according to its tracing</p>
<p>It starts by sorting the words by length.</p>
<p>The ECMAScript 3 reserved word list.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">isReservedWord3</span><span class="params">(str)</span> {</span>
        <span class="keyword">switch</span> (str.length) {
        <span class="keyword">case</span> <span class="number">3</span>:
            <span class="keyword">return</span> str===<span class="string">'int'</span>;
        <span class="keyword">case</span> <span class="number">4</span>:
            <span class="keyword">return</span> str===<span class="string">'byte'</span>||str===<span class="string">'char'</span>||str===<span class="string">'enum'</span>||str===<span class="string">'goto'</span>||str===<span class="string">'long'</span>;
        <span class="keyword">case</span> <span class="number">5</span>:
            <span class="keyword">return</span> str===<span class="string">'class'</span>||str===<span class="string">'final'</span>||str===<span class="string">'float'</span>||str===<span class="string">'short'</span>||str===<span class="string">'super'</span>;
        <span class="keyword">case</span> <span class="number">6</span>:
            <span class="keyword">return</span> str===<span class="string">'double'</span>||str===<span class="string">'export'</span>||str===<span class="string">'import'</span>||str===<span class="string">'native'</span>||str===<span class="string">'public'</span>||str===<span class="string">'static'</span>||str===<span class="string">'throws'</span>;
        <span class="keyword">case</span> <span class="number">7</span>:
            <span class="keyword">return</span> str===<span class="string">'boolean'</span>||str===<span class="string">'extends'</span>||str===<span class="string">'package'</span>||str===<span class="string">'private'</span>;
        <span class="keyword">case</span> <span class="number">8</span>:
            <span class="keyword">return</span> str===<span class="string">'abstract'</span>||str===<span class="string">'volatile'</span>;
        <span class="keyword">case</span> <span class="number">9</span>:
            <span class="keyword">return</span> str===<span class="string">'interface'</span>||str===<span class="string">'protected'</span>||str===<span class="string">'transient'</span>;
        <span class="keyword">case</span> <span class="number">10</span>:
            <span class="keyword">return</span> str===<span class="string">'implements'</span>;
        <span class="keyword">case</span> <span class="number">12</span>:
            <span class="keyword">return</span> str===<span class="string">'synchronized'</span>;
        <span class="keyword">default</span>:
            <span class="keyword">return</span> <span class="literal">false</span>;
        }
    }</pre></div>
        
      
        
        <p>ECMAScript 5 reserved words.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">isReservedWord5</span><span class="params">(str)</span> {</span>
        <span class="keyword">switch</span> (str.length) {
        <span class="keyword">case</span> <span class="number">4</span>:
            <span class="keyword">return</span> str === <span class="string">'enum'</span>;
        <span class="keyword">case</span> <span class="number">5</span>:
            <span class="keyword">return</span> str === <span class="string">'class'</span> || str === <span class="string">'super'</span>;
        <span class="keyword">case</span> <span class="number">6</span>:
            <span class="keyword">return</span> str === <span class="string">'export'</span> || str === <span class="string">'import'</span>;
        <span class="keyword">case</span> <span class="number">7</span>:
            <span class="keyword">return</span> str === <span class="string">'extends'</span>;
        <span class="keyword">default</span>:
            <span class="keyword">return</span> <span class="literal">false</span>;
        }
    }</pre></div>
        
      
        
        <p>The additional reserved words in strict mode.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">isStrictReservedWord</span><span class="params">(str)</span> {</span>
        <span class="keyword">switch</span> (str.length) {
        <span class="keyword">case</span> <span class="number">3</span>:
            <span class="keyword">return</span> str === <span class="string">'let'</span>;
        <span class="keyword">case</span> <span class="number">5</span>:
            <span class="keyword">return</span> str === <span class="string">'yield'</span>;
        <span class="keyword">case</span> <span class="number">6</span>:
            <span class="keyword">return</span> str === <span class="string">'static'</span> || str === <span class="string">'public'</span>;
        <span class="keyword">case</span> <span class="number">7</span>:
            <span class="keyword">return</span> str === <span class="string">'private'</span> || str === <span class="string">'package'</span>;
        <span class="keyword">case</span> <span class="number">9</span>:
            <span class="keyword">return</span> str === <span class="string">'interface'</span> || str === <span class="string">'protected'</span>;
        <span class="keyword">case</span> <span class="number">10</span>:
            <span class="keyword">return</span> str === <span class="string">'implements'</span>;
        <span class="keyword">default</span>:
            <span class="keyword">return</span> <span class="literal">false</span>;
        }
    }</pre></div>
        
      
        
        <p>The forbidden variable names in strict mode.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">isStrictBadIdWord</span><span class="params">(str)</span> {</span>
        <span class="keyword">return</span> str === <span class="string">'eval'</span> || str === <span class="string">'arguments'</span>;
    }</pre></div>
        
      
        
        <p>And the keywords.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">isKeyword</span><span class="params">(str)</span> {</span>
        <span class="keyword">switch</span> (tokPos - tokStart) {
        <span class="keyword">case</span> <span class="number">4</span>:
            <span class="keyword">switch</span> (str) {
            <span class="keyword">case</span> <span class="string">'null'</span>: <span class="keyword">return</span> _<span class="literal">null</span>;
            <span class="keyword">case</span> <span class="string">'true'</span>: <span class="keyword">return</span> _<span class="literal">true</span>;
            <span class="keyword">case</span> <span class="string">'this'</span>: <span class="keyword">return</span> _<span class="keyword">this</span>;
            <span class="keyword">case</span> <span class="string">'with'</span>: <span class="keyword">return</span> _<span class="keyword">with</span>;
            <span class="keyword">case</span> <span class="string">'void'</span>: <span class="keyword">return</span> _<span class="keyword">void</span>;
            <span class="keyword">case</span> <span class="string">'else'</span>: <span class="keyword">return</span> _<span class="keyword">else</span>;
            <span class="keyword">case</span> <span class="string">'case'</span>: tokRegexpAllowed = <span class="literal">true</span>; <span class="keyword">return</span> _<span class="keyword">case</span>;
            }
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">5</span>:
            <span class="keyword">switch</span> (str) {
            <span class="keyword">case</span> <span class="string">'false'</span>: <span class="keyword">return</span> _<span class="literal">false</span>;
            <span class="keyword">case</span> <span class="string">'break'</span>: <span class="keyword">return</span> _<span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">'while'</span>: <span class="keyword">return</span> _<span class="keyword">while</span>;
            <span class="keyword">case</span> <span class="string">'catch'</span>: <span class="keyword">return</span> _<span class="keyword">catch</span>;
            <span class="keyword">case</span> <span class="string">'throw'</span>: <span class="keyword">return</span> _<span class="keyword">throw</span>;
            }
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">3</span>:
            <span class="keyword">switch</span> (str) {
            <span class="keyword">case</span> <span class="string">'var'</span>: <span class="keyword">return</span> _<span class="keyword">var</span>;
            <span class="keyword">case</span> <span class="string">'for'</span>: <span class="keyword">return</span> _<span class="keyword">for</span>;
            <span class="keyword">case</span> <span class="string">'try'</span>: <span class="keyword">return</span> _<span class="keyword">try</span>;
            <span class="keyword">case</span> <span class="string">'new'</span>: <span class="keyword">return</span> _<span class="keyword">new</span>;
            }
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">6</span>:
            <span class="keyword">switch</span> (str) {
            <span class="keyword">case</span> <span class="string">'switch'</span>: <span class="keyword">return</span> _<span class="keyword">switch</span>;
            <span class="keyword">case</span> <span class="string">'typeof'</span>: tokRegexpAllowed = <span class="literal">true</span>; <span class="keyword">return</span> _<span class="keyword">typeof</span>;
            <span class="keyword">case</span> <span class="string">'delete'</span>: <span class="keyword">return</span> _<span class="keyword">delete</span>;
            <span class="keyword">case</span> <span class="string">'return'</span>: tokRegexpAllowed = <span class="literal">true</span>; <span class="keyword">return</span> _<span class="keyword">return</span>;
            }
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">8</span>:
            <span class="keyword">switch</span> (str) {
            <span class="keyword">case</span> <span class="string">'function'</span>: <span class="keyword">return</span> _<span class="keyword">function</span>;
            <span class="keyword">case</span> <span class="string">'continue'</span>: <span class="keyword">return</span> _<span class="keyword">continue</span>;
            <span class="keyword">case</span> <span class="string">'debugger'</span>: <span class="keyword">return</span> _debugger;
            }
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">2</span>:
            <span class="keyword">switch</span> (str) {
            <span class="keyword">case</span> <span class="string">'if'</span>: <span class="keyword">return</span> _<span class="keyword">if</span>;
            <span class="keyword">case</span> <span class="string">'do'</span>: <span class="keyword">return</span> _<span class="keyword">do</span>;
            <span class="keyword">case</span> <span class="string">'in'</span>: tokRegexpAllowed = <span class="literal">true</span>; <span class="keyword">return</span> _<span class="keyword">in</span>;
            }
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">7</span>:
            <span class="keyword">switch</span> (str) {
            <span class="keyword">case</span> <span class="string">'default'</span>: <span class="keyword">return</span> _<span class="keyword">default</span>;
            <span class="keyword">case</span> <span class="string">'finally'</span>: <span class="keyword">return</span> _<span class="keyword">finally</span>;
            }
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">10</span>:
            <span class="keyword">if</span> (str === <span class="string">'instanceof'</span>) {<span class="keyword">return</span> _<span class="keyword">instanceof</span>;}
            <span class="keyword">break</span>;
        }
        <span class="keyword">return</span> _name;
    }</pre></div>
        
      
        
        <h2>Character categories</h2>
<p>Whether a single character denotes a newline.</p>

        
          <div class='highlight'><pre>    <span class="keyword">var</span> newline = <span class="regexp">/[\n\r\u2028\u2029]/</span>;</pre></div>
        
      
        
        <p>Matches a whole line break (where CRLF is considered a single
line break). Used to count lines.</p>

        
          <div class='highlight'><pre>    <span class="keyword">var</span> lineBreak = <span class="regexp">/\r\n|[\n\r\u2028\u2029]/g</span>;</pre></div>
        
      
        
        <p>Big ugly regular expressions that match characters in the
whitespace, identifier, and identifier-start categories. These
are only applied when a character is found to actually have a
code point above 128.</p>

        
          <div class='highlight'><pre>    <span class="keyword">var</span> nonASCIIidentifierStartChars = <span class="string">'\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc'</span>;
    <span class="keyword">var</span> nonASCIIidentifierChars = <span class="string">'\u0371-\u0374\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f'</span>;
    <span class="keyword">var</span> nonASCIIidentifierStart = <span class="keyword">new</span> RegExp(<span class="string">'['</span> + nonASCIIidentifierStartChars + <span class="string">']'</span>);
    <span class="keyword">var</span> nonASCIIidentifier = <span class="keyword">new</span> RegExp(<span class="string">'['</span> + nonASCIIidentifierStartChars + nonASCIIidentifierChars + <span class="string">']'</span>);</pre></div>
        
      
        
        <p>Test whether a given character code starts an identifier.</p>

        
          <div class='highlight'><pre>    <span class="keyword">var</span> isIdentifierStart = <span class="keyword">new</span> Array(<span class="number">65536</span>);
    <span class="keyword">var</span> isIdentifierChar = <span class="keyword">new</span> Array(<span class="number">65536</span>);

    <span class="function"><span class="keyword">function</span> <span class="title">isIdentifierStart_fn</span><span class="params">(code)</span> {</span>
        <span class="keyword">if</span> (code &lt; <span class="number">65</span>) <span class="keyword">return</span> code === <span class="number">36</span>;
        <span class="keyword">if</span> (code &lt; <span class="number">91</span>) <span class="keyword">return</span> <span class="literal">true</span>;
        <span class="keyword">if</span> (code &lt; <span class="number">97</span>) <span class="keyword">return</span> code === <span class="number">95</span>;
        <span class="keyword">if</span> (code &lt; <span class="number">123</span>)<span class="keyword">return</span> <span class="literal">true</span>;
        <span class="keyword">if</span> (code &gt;= <span class="number">0xaa</span>) {
            <span class="keyword">return</span> nonASCIIidentifierStart.test(String.fromCharCode(code));
        }
        <span class="keyword">return</span> <span class="literal">false</span>;
    }</pre></div>
        
      
        
        <p>Test whether a given character is part of an identifier.</p>
<p><a href="http://jsperf.com/isidentifierchar/4">http://jsperf.com/isidentifierchar/4</a></p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">isIdentifierChar_fn</span><span class="params">(code)</span> {</span>
        <span class="keyword">if</span> (code &lt; <span class="number">48</span>) <span class="keyword">return</span> code === <span class="number">36</span>;
        <span class="keyword">if</span> (code &lt; <span class="number">58</span>) <span class="keyword">return</span> <span class="literal">true</span>;
        <span class="keyword">if</span> (code &lt; <span class="number">65</span>) <span class="keyword">return</span> <span class="literal">false</span>;
        <span class="keyword">if</span> (code &lt; <span class="number">91</span>) <span class="keyword">return</span> <span class="literal">true</span>;
        <span class="keyword">if</span> (code &lt; <span class="number">97</span>) <span class="keyword">return</span> code === <span class="number">95</span>;
        <span class="keyword">if</span> (code &lt; <span class="number">123</span>)<span class="keyword">return</span> <span class="literal">true</span>;
        <span class="keyword">if</span> (code &gt;= <span class="number">0xaa</span>) {
            <span class="keyword">return</span> nonASCIIidentifier.test(String.fromCharCode(code));
        }
        <span class="keyword">return</span> <span class="literal">false</span>;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">setupIdentCharLUTs</span><span class="params">()</span> {</span>
        <span class="keyword">for</span>(<span class="keyword">var</span> ix=<span class="number">0</span>;ix&lt;<span class="number">65536</span>;ix++) {
            isIdentifierStart[ix] = isIdentifierStart_fn(ix);
            isIdentifierChar[ix] = isIdentifierChar_fn(ix);
        }
    }
    setupIdentCharLUTs();</pre></div>
        
      
        
        <h2>Tokenizer</h2>
<p>Reset the token state. Used at the start of a parse.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">initTokenState</span><span class="params">()</span> {</span>
        tokPos = <span class="number">0</span>;
        tokRegexpAllowed = <span class="literal">true</span>;
        skipSpace();
    }</pre></div>
        
      
        
        <p>Called at the end of every token. Sets <code>tokEnd</code>, <code>tokVal</code>, and
<code>tokRegexpAllowed</code>, and skips the space after the token, so that
the next one&#39;s <code>tokStart</code> will point at the right position.</p>
<p>if (options.locations) tokEndLoc = new line_loc_t();</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">finishToken</span><span class="params">(type, val)</span> {</span>
        tokEnd = tokPos;
        tokType = type;
        tokVal = val;
        skipSpace();
    }</pre></div>
        
      
        
        <p>Skip a block comment &#39;/<em> ... </em>/&#39;
<a href="http://jsperf.com/skipblockcomment/2">http://jsperf.com/skipblockcomment/2</a></p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">skipBlockComment</span><span class="params">()</span> {</span>
        tokPos += <span class="number">2</span>;
        <span class="keyword">var</span> end = input.indexOf(<span class="string">'*/'</span>, tokPos);
        <span class="keyword">if</span> (end === -<span class="number">1</span>) raise(tokPos - <span class="number">2</span>, <span class="string">'Unterminated comment'</span>);
        tokPos = end + <span class="number">2</span>;
    }</pre></div>
        
      
        
        <p>Skip a line comment &#39;// ... <newline>&#39;
<a href="http://jsperf.com/skiplinecomment/2">http://jsperf.com/skiplinecomment/2</a></p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">skipLineComment</span><span class="params">()</span> {</span>
        tokPos += <span class="number">2</span>;
        <span class="keyword">var</span> ch = input.charCodeAt(tokPos);
        <span class="keyword">while</span> (ch !== <span class="number">10</span> &amp;&amp; ch !== <span class="number">13</span> &amp;&amp; tokPos &lt; inputLen &amp;&amp; ch !== <span class="number">8232</span> &amp;&amp; ch !== <span class="number">8329</span>) {
            ++tokPos;
            ch = input.charCodeAt(tokPos);
        }
    }</pre></div>
        
      
        
        <p>Called at the start of the parse and after every token. Skips
whitespace and comments.
<a href="http://jsperf.com/skipspace/4">http://jsperf.com/skipspace/4</a></p>

        
          <div class='highlight'><pre>    <span class="keyword">var</span> ch_ = <span class="number">0</span>;
    <span class="function"><span class="keyword">function</span> <span class="title">skipSpace</span><span class="params">()</span> {</span>
        <span class="keyword">while</span> (tokPos &lt; inputLen) {
            ch_ = input.charCodeAt(tokPos);
            <span class="keyword">switch</span>(ch_) {
            <span class="keyword">case</span> <span class="number">9</span>:
            <span class="keyword">case</span> <span class="number">10</span>:
            <span class="keyword">case</span> <span class="number">11</span>:
            <span class="keyword">case</span> <span class="number">12</span>:
            <span class="keyword">case</span> <span class="number">32</span>:
            <span class="keyword">case</span> <span class="number">160</span>:
            <span class="keyword">case</span> <span class="number">0x1680</span>:
            <span class="keyword">case</span> <span class="number">0x180e</span>:
            <span class="keyword">case</span> <span class="number">0x2028</span>:
            <span class="keyword">case</span> <span class="number">0x2029</span>:
            <span class="keyword">case</span> <span class="number">0x202f</span>:
            <span class="keyword">case</span> <span class="number">0x205f</span>:
            <span class="keyword">case</span> <span class="number">0x3000</span>:
            <span class="keyword">case</span> <span class="number">0xfeff</span>:
                ++tokPos;
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="number">47</span>:
                ch_ = input.charCodeAt(tokPos+<span class="number">1</span>);
                <span class="keyword">if</span> (ch_ === <span class="number">42</span>) {skipBlockComment();}
                <span class="keyword">else</span> <span class="keyword">if</span> (ch_ === <span class="number">47</span>) {skipLineComment();}
                <span class="keyword">else</span> <span class="keyword">return</span>;
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="number">13</span>:
                ++tokPos;
                ch_ = input.charCodeAt(tokPos);
                <span class="keyword">if</span> (ch_ === <span class="number">10</span>) {
                    ++tokPos;
                }
                <span class="keyword">break</span>;
            <span class="keyword">default</span>:
                <span class="keyword">if</span> (ch_ &gt;= <span class="number">0x2000</span> &amp;&amp; ch_ &lt;= <span class="number">0x200a</span>) {
                    ++tokPos;
                } <span class="keyword">else</span> {
                    <span class="keyword">return</span>;
                }
            }
        }
    }</pre></div>
        
      
        
        <h3>Token reading</h3>

        
          <div class='highlight'><pre>    <span class="keyword">var</span> nextChar = <span class="number">0</span>;</pre></div>
        
      
        
        <p>Read &#39;.[0-9]&#39; and &#39;.&#39;
The interpretation of a dot depends on whether it is followed
by a digit.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">readToken_dot</span><span class="params">()</span> {</span>
        nextChar = input.charCodeAt(tokPos+<span class="number">1</span>);
        <span class="keyword">if</span> (nextChar &gt;= <span class="number">48</span> &amp;&amp; nextChar &lt;= <span class="number">57</span>) {
            readNumber(<span class="number">46</span>);
        } <span class="keyword">else</span> {
            ++tokPos;
            tokRegexpAllowed = <span class="literal">true</span>;
            finishToken(_dot);
        }
    }</pre></div>
        
      
        
        <p>Read &#39;/=&#39; and &#39;=&#39;
Line and block comments are skipped by skipSpace before we get here</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">readToken_slash</span><span class="params">()</span> {</span>
        ++tokPos;
        <span class="keyword">if</span> (tokRegexpAllowed) {
            readRegexp();
            <span class="keyword">return</span>;
        }

        nextChar = input.charCodeAt(tokPos);

        <span class="keyword">if</span> (nextChar === <span class="number">61</span>) {
            ++tokPos;
            finishToken(_assign, AssignmentOperator.div);
        } <span class="keyword">else</span> {
            finishToken(_slash, BinaryOperator.div);
        }
        tokRegexpAllowed = <span class="literal">true</span>;
    }</pre></div>
        
      
        
        <p>Read &#39;<em>=&#39; and &#39;</em>&#39;</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">readToken_multiply</span><span class="params">()</span> {</span>
        ++tokPos;
        nextChar = input.charCodeAt(tokPos);
        <span class="keyword">if</span> (nextChar === <span class="number">61</span>) {
            ++tokPos;
            finishToken(_assign, AssignmentOperator.mult);
        } <span class="keyword">else</span> {
            finishToken(_bin10, BinaryOperator.mult);
        }
        tokRegexpAllowed = <span class="literal">true</span>;
    }</pre></div>
        
      
        
        <p>Read &#39;%=&#39; and &#39;%&#39;</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">readToken_modulo</span><span class="params">()</span> {</span>
        ++tokPos;
        nextChar = input.charCodeAt(tokPos);
        <span class="keyword">if</span> (nextChar === <span class="number">61</span>) {
            ++tokPos;
            finishToken(_assign, AssignmentOperator.modulo);
        } <span class="keyword">else</span> {
            finishToken(_bin10, BinaryOperator.modulo);
        }
        tokRegexpAllowed = <span class="literal">true</span>;
    }</pre></div>
        
      
        
        <p>Read &#39;||&#39;, &#39;|=&#39; and &#39;|&#39;</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">readToken_OR</span><span class="params">()</span> {</span>
        ++tokPos;
        nextChar = input.charCodeAt(tokPos);
        <span class="keyword">if</span> (nextChar === <span class="number">124</span>) {
            ++tokPos;
            finishToken(_bin1, LogicalOperator.OR);
        } <span class="keyword">else</span> <span class="keyword">if</span> (nextChar === <span class="number">61</span>) {
            ++tokPos;
            finishToken(_assign, AssignmentOperator.OR);
        } <span class="keyword">else</span> {
            finishToken(_bin3, BinaryOperator.OR);
        }
        tokRegexpAllowed = <span class="literal">true</span>;
    }</pre></div>
        
      
        
        <p>Read &#39;&amp;&amp;&#39;, &#39;&amp;=&#39; and &#39;&amp;&#39;</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">readToken_AND</span><span class="params">()</span> {</span>
        ++tokPos;
        nextChar = input.charCodeAt(tokPos);
        <span class="keyword">if</span> (nextChar === <span class="number">38</span>) {
            ++tokPos;
            finishToken(_bin2, LogicalOperator.AND);
        } <span class="keyword">else</span> <span class="keyword">if</span> (nextChar === <span class="number">61</span>) {
            ++tokPos;
            finishToken(_assign, AssignmentOperator.AND);
        } <span class="keyword">else</span> {
            finishToken(_bin5, BinaryOperator.AND);
        }
        tokRegexpAllowed = <span class="literal">true</span>;
    }</pre></div>
        
      
        
        <p>Read &#39;^=&#39; and &#39;^&#39;</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">readToken_XOR</span><span class="params">()</span> {</span>
        ++tokPos;
        nextChar = input.charCodeAt(tokPos);
        <span class="keyword">if</span> (nextChar === <span class="number">61</span>) {
            ++tokPos;
            finishToken(_assign, AssignmentOperator.XOR);
        } <span class="keyword">else</span> {
            finishToken(_bin4, BinaryOperator.XOR);
        }
        tokRegexpAllowed = <span class="literal">true</span>;
    }</pre></div>
        
      
        
        <p>Read &#39;++&#39;, &#39;+=&#39; and &#39;+&#39;</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">readToken_plus</span><span class="params">()</span> {</span>
        ++tokPos;
        nextChar = input.charCodeAt(tokPos);
        <span class="keyword">if</span> (nextChar === <span class="number">43</span>) {
            ++tokPos;
            finishToken(_incdec, UpdateOperator.increment);
        } <span class="keyword">else</span> <span class="keyword">if</span> (nextChar === <span class="number">61</span>) {
            ++tokPos;
            finishToken(_assign, AssignmentOperator.plus);
        } <span class="keyword">else</span> {
            finishToken(_plusmin, UnaryOperator.plus);
        }
        tokRegexpAllowed = <span class="literal">true</span>;
    }</pre></div>
        
      
        
        <p>Read &#39;--&#39;, &#39;-=&#39; and &#39;-&#39;</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">readToken_minus</span><span class="params">()</span> {</span>
        ++tokPos;
        nextChar = input.charCodeAt(tokPos);
        <span class="keyword">if</span> (nextChar === <span class="number">45</span>) {
            ++tokPos;
            finishToken(_incdec, UpdateOperator.decrement);
        } <span class="keyword">else</span> <span class="keyword">if</span> (nextChar === <span class="number">61</span>) {
            ++tokPos;
            finishToken(_assign, AssignmentOperator.minus);
        } <span class="keyword">else</span> {
            finishToken(_plusmin, UnaryOperator.minus);
        }
        tokRegexpAllowed = <span class="literal">true</span>;
    }</pre></div>
        
      
        
        <p>Read &#39;&lt;&lt;=&#39; and &#39;&lt;&lt;&#39;</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">readToken_leftShift</span><span class="params">()</span> {</span>
        <span class="keyword">if</span> (input.charCodeAt(tokPos + <span class="number">1</span>) === <span class="number">61</span>) {
            tokPos += <span class="number">2</span>;
            finishToken(_assign, AssignmentOperator.left_shift);
        } <span class="keyword">else</span> {
            ++tokPos;
            finishToken(_bin8, BinaryOperator.left_shift);
        }
    }</pre></div>
        
      
        
        <p>Read &#39;&lt;=&#39; and &#39;&lt;&#39;</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">readToken_lessThan</span><span class="params">()</span> {</span>
        ++tokPos;
        nextChar = input.charCodeAt(tokPos);
        <span class="keyword">if</span> (nextChar === <span class="number">60</span>) {
            readToken_leftShift();
        } <span class="keyword">else</span> {
            <span class="keyword">if</span> (nextChar === <span class="number">61</span>) {
                ++tokPos;
                finishToken(_bin8, BinaryOperator.lt_eq);
            } <span class="keyword">else</span> {
                finishToken(_bin7, BinaryOperator.lt);
            }
        }
        tokRegexpAllowed = <span class="literal">true</span>;
    }</pre></div>
        
      
        
        <p>Read &#39;&gt;&gt;=&#39;, &#39;&gt;&gt;&gt;=&#39;, &#39;&gt;&gt;&gt;&#39; and &#39;&gt;&gt;&#39;</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">readToken_rightShift</span><span class="params">()</span> {</span>
        nextChar = input.charCodeAt(tokPos + <span class="number">1</span>);

        <span class="keyword">if</span> (nextChar === <span class="number">61</span>) {
            tokPos += <span class="number">2</span>;
            finishToken(_assign, AssignmentOperator.right_shift);
        } <span class="keyword">else</span> <span class="keyword">if</span> (nextChar === <span class="number">62</span>) {
            nextChar = input.charCodeAt(tokPos + <span class="number">2</span>);
            <span class="keyword">if</span> (nextChar === <span class="number">61</span>) {
                tokPos += <span class="number">3</span>;
                finishToken(_assign, AssignmentOperator.zero_fill_right_shift);
            } <span class="keyword">else</span> {
                tokPos += <span class="number">2</span>;
                finishToken(_bin8, BinaryOperator.zero_fill_right_shift);
            }
        } <span class="keyword">else</span> {
            ++tokPos;
            finishToken(_bin8, BinaryOperator.right_shift);
        }
    }</pre></div>
        
      
        
        <p>Read &#39;&gt;=&#39; and &#39;&gt;&#39;</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">readToken_greaterThan</span><span class="params">()</span> {</span>
        ++tokPos;
        nextChar = input.charCodeAt(tokPos);
        <span class="keyword">if</span> (nextChar === <span class="number">62</span>) {
            readToken_rightShift();
        } <span class="keyword">else</span> {
            <span class="keyword">if</span> (nextChar === <span class="number">61</span>) {
                ++tokPos;
                finishToken(_bin8, BinaryOperator.gt_eq);
            } <span class="keyword">else</span> {
                finishToken(_bin7, BinaryOperator.gt);
            }
        }
        tokRegexpAllowed = <span class="literal">true</span>;
    }</pre></div>
        
      
        
        <p>Read &#39;!==&#39;, &#39;!=&#39; and &#39;!&#39;</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">readToken_exclamation</span><span class="params">()</span> {</span>
        ++tokPos;
        nextChar = input.charCodeAt(tokPos);
        <span class="keyword">if</span> (nextChar === <span class="number">61</span>) {
            <span class="keyword">if</span> (input.charCodeAt(tokPos+<span class="number">1</span>) === <span class="number">61</span>) {
                tokPos += <span class="number">2</span>;
                finishToken(_bin6, BinaryOperator.ex_eq_eq);
            } <span class="keyword">else</span> {
            ++tokPos;
                finishToken(_bin6, BinaryOperator.ex_eq);
            }
        } <span class="keyword">else</span> {
            finishToken(_prefix, UnaryOperator.ex);
        }
        tokRegexpAllowed = <span class="literal">true</span>;
    }</pre></div>
        
      
        
        <p>Read &#39;===&#39;, &#39;==&#39; and &#39;=&#39;</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">readToken_equal</span><span class="params">()</span> {</span>
        ++tokPos;
        nextChar = input.charCodeAt(tokPos);
        <span class="keyword">if</span> (nextChar === <span class="number">61</span>) {
            ++tokPos;
            <span class="keyword">if</span> (input.charCodeAt(tokPos) === <span class="number">61</span>) {
                ++tokPos;
                finishToken(_bin6, BinaryOperator.eq_eq_eq);
            } <span class="keyword">else</span> {
                finishToken(_bin6, BinaryOperator.eq_eq);
            }
        } <span class="keyword">else</span> {
            finishToken(_eq, AssignmentOperator.eq);
        }
        tokRegexpAllowed = <span class="literal">true</span>;
    }</pre></div>
        
      
        
        <p>Read &#39;~&#39;</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">readToken_BITWISE_NOT</span><span class="params">()</span> {</span>
        ++tokPos;
        finishToken(_prefix, UnaryOperator.BITWISE_NOT);
        tokRegexpAllowed = <span class="literal">true</span>;
    }</pre></div>
        
      
        
        <p>Read &#39;0[0-9.eExX]&#39;</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">readMaybeHex</span><span class="params">()</span> {</span>
        nextChar = input.charCodeAt(tokPos+<span class="number">1</span>);
        <span class="keyword">if</span> (nextChar === <span class="number">120</span> || nextChar === <span class="number">88</span>) {
            readHexNumber();
        } <span class="keyword">else</span> {
            readNumber(<span class="number">48</span>);
        }
    }</pre></div>
        
      
        
        <p>If we are here, we either found a non-ASCII identifier
character, or something that&#39;s entirely disallowed.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">readToken_default</span><span class="params">(code)</span> {</span>
        <span class="keyword">var</span> ch = String.fromCharCode(code);
        <span class="keyword">if</span> (code === <span class="number">92</span>) {
            finishToken(_name, readWord_Esc(<span class="string">''</span>, isIdentifierStart));
        } <span class="keyword">else</span> <span class="keyword">if</span> (nonASCIIidentifierStart.test(ch)) {
            readWord();
        } <span class="keyword">else</span> {
            raise(tokPos, <span class="string">'Unexpected character \''</span> + ch + <span class="string">'\''</span>);
        }

    }

    <span class="function"><span class="keyword">function</span> <span class="title">getTokenFromCode</span><span class="params">(code)</span> {</span>
        <span class="keyword">switch</span>(code) {
        <span class="keyword">case</span> <span class="number">46</span>: readToken_dot(); <span class="keyword">break</span>;</pre></div>
        
      
        
        <p>Punctuation tokens.</p>

        
          <div class='highlight'><pre>        <span class="keyword">case</span> <span class="number">40</span>: ++tokPos; tokRegexpAllowed = <span class="literal">true</span>; finishToken(_parenL); <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">41</span>: ++tokPos; tokRegexpAllowed = <span class="literal">false</span>; finishToken(_parenR); <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">59</span>: ++tokPos; tokRegexpAllowed = <span class="literal">true</span>; finishToken(_semi); <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">44</span>: ++tokPos; tokRegexpAllowed = <span class="literal">true</span>; finishToken(_comma); <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">91</span>: ++tokPos; tokRegexpAllowed = <span class="literal">true</span>; finishToken(_bracketL); <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">93</span>: ++tokPos; tokRegexpAllowed = <span class="literal">false</span>; finishToken(_bracketR); <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">123</span>: ++tokPos; tokRegexpAllowed = <span class="literal">true</span>; finishToken(_braceL); <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">125</span>: ++tokPos; tokRegexpAllowed = <span class="literal">false</span>; finishToken(_braceR); <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">58</span>: ++tokPos; tokRegexpAllowed = <span class="literal">true</span>; finishToken(_colon); <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">63</span>: ++tokPos; tokRegexpAllowed = <span class="literal">true</span>; finishToken(_question); <span class="keyword">break</span>;</pre></div>
        
      
        
        <p>&#39;0x&#39; is a hexadecimal number.</p>

        
          <div class='highlight'><pre>        <span class="keyword">case</span> <span class="number">48</span>: readMaybeHex(); <span class="keyword">break</span>;</pre></div>
        
      
        
        <p>Anything else beginning with a digit is an integer, octal
number, or float.</p>

        
          <div class='highlight'><pre>        <span class="keyword">case</span> <span class="number">49</span>: <span class="keyword">case</span> <span class="number">50</span>: <span class="keyword">case</span> <span class="number">51</span>: <span class="keyword">case</span> <span class="number">52</span>: <span class="keyword">case</span> <span class="number">53</span>: <span class="keyword">case</span> <span class="number">54</span>: <span class="keyword">case</span> <span class="number">55</span>: <span class="keyword">case</span> <span class="number">56</span>: <span class="keyword">case</span> <span class="number">57</span>: <span class="comment">// 1-9</span>
            readNumber(code);
            <span class="keyword">break</span>;</pre></div>
        
      
        
        <p>Quotes produce strings.</p>

        
          <div class='highlight'><pre>        <span class="keyword">case</span> <span class="number">34</span>: <span class="keyword">case</span> <span class="number">39</span>: readString(code); <span class="keyword">break</span>;

        <span class="keyword">case</span> <span class="number">47</span>: readToken_slash(); <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">124</span>: readToken_OR(); <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">38</span>: readToken_AND(); <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">94</span>: readToken_XOR(); <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">60</span>: readToken_lessThan(); <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">62</span>: readToken_greaterThan(); <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">61</span>: readToken_equal(); <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">33</span>: readToken_exclamation(); <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">126</span>: readToken_BITWISE_NOT(); <span class="keyword">break</span>;

        <span class="keyword">case</span> <span class="number">37</span>: readToken_modulo(); <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">42</span>: readToken_multiply(); <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">43</span>: readToken_plus(); <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">45</span>: readToken_minus(); <span class="keyword">break</span>;

        <span class="keyword">default</span>:
            readToken_default(code);
        }
    }

    <span class="function"><span class="keyword">function</span> <span class="title">readToken_forceRegexp</span><span class="params">()</span> {</span>
        tokStart = tokPos;</pre></div>
        
      
        
        <pre><code>   if (options.locations) tokStartLoc = new line_loc_t();
   tokCommentsBefore = tokComments;</code></pre>

        
          <div class='highlight'><pre>        <span class="keyword">return</span> readRegexp();
    }

    <span class="function"><span class="keyword">function</span> <span class="title">readToken</span><span class="params">()</span> {</span></pre></div>
        
      
        
        <p>readToken is necessarily big to avoid inlining in v8!
readToken is necessarily big to avoid inlining in v8!
readToken is necessarily big to avoid inlining in v8!
readToken is necessarily big to avoid inlining in v8!
readToken is necessarily big to avoid inlining in v8!
readToken is necessarily big to avoid inlining in v8!
readToken is necessarily big to avoid inlining in v8!</p>
<pre><code>if (options.locations) tokStartLoc = new line_loc_t();</code></pre>

        
          <div class='highlight'><pre>        <span class="keyword">if</span> (tokPos &gt;= inputLen) {
            finishToken(_eof);
        } <span class="keyword">else</span> {
            <span class="keyword">var</span> code = input.charCodeAt(tokPos);

            tokStart = tokPos;</pre></div>
        
      
        
        <p>Identifier or keyword. &#39;\uXXXX&#39; sequences are allowed in
identifiers, so &#39;\&#39; also dispatches to that.</p>

        
          <div class='highlight'><pre>            <span class="keyword">if</span> (isIdentifierStart[code]===<span class="literal">true</span>) {
                readWord();
            } <span class="keyword">else</span> <span class="keyword">if</span> (code === <span class="number">92</span>) { <span class="comment">// '\'</span>
                finishToken(_name, readWord_Esc(<span class="string">''</span>, isIdentifierStart));
            } <span class="keyword">else</span> {
                getTokenFromCode(code);
            }
        }
    }</pre></div>
        
      
        
        <p>Parse a regular expression. Some context-awareness is necessary,
since a &#39;/&#39; inside a &#39;[]&#39; set does not end the expression.
<a href="http://jsperf.com/readregexp/5">http://jsperf.com/readregexp/5</a></p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">readRegexp</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> start = tokPos;
        <span class="keyword">var</span> flags = <span class="number">0</span>; <span class="comment">// ESCAPED | IN CLASS</span>
        <span class="keyword">var</span> ch = <span class="number">0</span>;

        <span class="keyword">for</span> (;;) {
            ch = input.charCodeAt(tokPos);
            <span class="keyword">if</span> (tokPos &gt;= inputLen || ch === <span class="number">10</span> || ch === <span class="number">13</span> || ch === <span class="number">8232</span> || ch === <span class="number">8329</span>) {
                raise(start, <span class="string">'Unterminated regular expression'</span>);
            }
            <span class="keyword">if</span> ((flags &amp; <span class="number">1</span>) !== <span class="number">0</span>) { <span class="comment">// escaped</span>
                flags &amp;= <span class="number">2</span>; <span class="comment">// escaped = false</span>
            } <span class="keyword">else</span> {
                <span class="keyword">if</span> (ch === <span class="number">91</span>) { <span class="comment">// '['</span>
                    flags |= <span class="number">2</span>; <span class="comment">// inclass = true</span>
                } <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="number">93</span> &amp;&amp; (flags &amp; <span class="number">2</span>) !== <span class="number">0</span>) {
                    flags &amp;= <span class="number">1</span>; <span class="comment">// inclass = false</span>
                } <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="number">47</span> &amp;&amp; (flags &amp; <span class="number">2</span> ^ <span class="number">2</span>) !== <span class="number">0</span>) { <span class="comment">// inclass == false</span>
                    <span class="keyword">break</span>;
                } <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="number">92</span>) {
                    flags |= <span class="number">1</span>; <span class="comment">// escaped = true</span>
                }
            }
            ++tokPos;
        }
        <span class="keyword">var</span> content = input.substring(start, tokPos);
        ++tokPos;

        tokRegexpAllowed = <span class="literal">false</span>;

        finishToken(_regexp, <span class="keyword">new</span> RegExp(content, readWord_regexpMods()));
    }</pre></div>
        
      
        
        <p>Read a hex number with optionally specified length
Reads the numeric side of \x[0-9]{2}, \u[0-9]{4}, \U[0-9]{8}, and 0x[0-9]+
<a href="http://jsperf.com/readhex/4">http://jsperf.com/readhex/4</a></p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">readInt16</span><span class="params">(len)</span> {</span>
        <span class="keyword">var</span> start=tokPos, total=<span class="number">0</span>, code=<span class="number">0</span>, i=<span class="number">0</span>;
        len = len || <span class="literal">Infinity</span>;

        <span class="keyword">for</span>(;i&lt;len;i++,tokPos++) {
            code = input.charCodeAt(tokPos);
            <span class="keyword">if</span> (code &gt;= <span class="number">48</span> &amp;&amp; code &lt;= <span class="number">57</span>) {
                total = total * <span class="number">16</span> +  code - <span class="number">48</span>;
            } <span class="keyword">else</span> <span class="keyword">if</span> (code &gt;= <span class="number">97</span> &amp;&amp; code &lt;= <span class="number">102</span>) {
                total = total * <span class="number">16</span> + code - <span class="number">87</span>; <span class="comment">// 87 = 97 - 10</span>
            } <span class="keyword">else</span> <span class="keyword">if</span> (code &gt;= <span class="number">65</span> &amp;&amp; code &lt;= <span class="number">90</span>) {
                total = total * <span class="number">16</span> + code - <span class="number">55</span>; <span class="comment">// 55 = 65 - 10</span>
            }
            <span class="keyword">else</span> <span class="keyword">break</span>;
        }
        <span class="keyword">if</span> (tokPos === start || len !== <span class="literal">Infinity</span> &amp;&amp; tokPos - start !== len) <span class="keyword">return</span> <span class="literal">null</span>;
        <span class="keyword">return</span> total;
    }</pre></div>
        
      
        
        <p>Read 0x[0-9]+ with checks</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">readHexNumber</span><span class="params">()</span> {</span>
        tokPos += <span class="number">2</span>;
        <span class="keyword">var</span> val = readInt16(<span class="number">0</span>);
        <span class="keyword">if</span> (val === <span class="literal">null</span>) {
            raise(tokStart + <span class="number">2</span>, <span class="string">'Expected hexadecimal number'</span>);
        } <span class="keyword">else</span> <span class="keyword">if</span> (isIdentifierStart[input.charCodeAt(tokPos)]===<span class="literal">true</span>) {
            raise(tokPos, <span class="string">'Identifier directly after number'</span>);
        } <span class="keyword">else</span> {
            tokRegexpAllowed = <span class="literal">false</span>;
            finishToken(_num, val);
        }
    }</pre></div>
        
      
        
        <p>Read an integer, octal integer, or floating-point number.
<a href="http://jsperf.com/readnumber/3">http://jsperf.com/readnumber/3</a></p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">readNumber</span><span class="params">(code)</span> {</span>
        <span class="keyword">var</span> start = tokPos;
        <span class="keyword">var</span> flags = code === <span class="number">48</span> ? <span class="number">8</span> : <span class="number">0</span>;    <span class="comment">// FLOAT | EXP | OCTAL | ZERO-START</span>
        <span class="keyword">var</span> prev = <span class="number">0</span>;

        <span class="keyword">while</span>(tokPos &lt; inputLen) {
            <span class="keyword">if</span> (code &gt;= <span class="number">48</span> &amp;&amp; code &lt;= <span class="number">55</span>) {
            } <span class="keyword">else</span> <span class="keyword">if</span> (code === <span class="number">56</span> || code === <span class="number">57</span>) { <span class="comment">// 89</span>
                flags |= <span class="number">4</span>;
            } <span class="keyword">else</span> <span class="keyword">if</span> (code === <span class="number">46</span>) { <span class="comment">// '.'</span>
                <span class="keyword">if</span> ((flags &amp; <span class="number">1</span>) !== <span class="number">0</span>) {
                    <span class="keyword">break</span>;
                } <span class="keyword">else</span> {
                    flags |= <span class="number">1</span>;
                }
            } <span class="keyword">else</span> <span class="keyword">if</span> (code === <span class="number">43</span> || code === <span class="number">45</span>) { <span class="comment">// '+-'</span>
                <span class="keyword">if</span> (prev !== <span class="number">101</span> &amp;&amp; prev !== <span class="number">69</span>) { <span class="comment">// 'eE'</span>
                    <span class="keyword">break</span>;
                }
            } <span class="keyword">else</span> <span class="keyword">if</span> (code === <span class="number">101</span> || code === <span class="number">69</span>) { <span class="comment">// 'eE'</span>
                <span class="keyword">if</span> ((flags &amp; <span class="number">2</span>) !== <span class="number">0</span>) {
                    raise(tokPos, <span class="string">'Identifier directly after number'</span>);
                    <span class="keyword">break</span>;
                } <span class="keyword">else</span> {
                    flags |= <span class="number">3</span>;
                }
            } <span class="keyword">else</span> <span class="keyword">if</span> (isIdentifierStart[input.charCodeAt(tokPos)]===<span class="literal">true</span>) {
                <span class="keyword">if</span> ((flags &amp; <span class="number">2</span>) !== <span class="number">0</span>) {
                    raise(start, <span class="string">'Invalid number'</span>);
                } <span class="keyword">else</span> {
                    raise(tokPos, <span class="string">'Identifier directly after number'</span>);
                }
                <span class="keyword">break</span>;
            } <span class="keyword">else</span> <span class="keyword">if</span> (code &lt; <span class="number">48</span> || code &gt; <span class="number">57</span>) { <span class="comment">// 0-9</span>
                <span class="keyword">break</span>;
            }
            prev = code;
            code = input.charCodeAt(++tokPos);
        }

        <span class="keyword">if</span> ((flags &amp; <span class="number">3</span>) !== <span class="number">0</span> &amp;&amp; (prev === <span class="number">101</span> || prev === <span class="number">69</span> || prev === <span class="number">43</span> || prev === <span class="number">45</span>)) { <span class="comment">// 'eE','+-'</span>
            raise(start, <span class="string">'Invalid number'</span>);
        }

        <span class="keyword">if</span> ((flags &amp; <span class="number">1</span>) !== <span class="number">0</span>) {
            code = parseFloat(input.substring(start, tokPos));
        } <span class="keyword">else</span> <span class="keyword">if</span> ((flags &amp; <span class="number">8</span>) === <span class="number">0</span> || (tokPos - start) === <span class="number">1</span>) {
            code = parseFloat(input.substring(start, tokPos)) | <span class="number">0</span>;
        } <span class="keyword">else</span> <span class="keyword">if</span> (strict || (flags &amp; <span class="number">4</span>) !== <span class="number">0</span>) {
            raise(start, <span class="string">'Invalid number'</span>);
        } <span class="keyword">else</span> {
            code = parseInt(input.substring(start, tokPos), <span class="number">8</span>);
        }

        tokRegexpAllowed = <span class="literal">false</span>;
        finishToken(_num, code);
    }</pre></div>
        
      
        
        <p>Read octal literals \000 to \377</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">readOctalLiteral</span><span class="params">(ch)</span> {</span>
        <span class="keyword">var</span> shift = <span class="number">0</span>;
        <span class="keyword">var</span> ret = ch - <span class="number">48</span>;

        <span class="keyword">var</span> ch2 = input.charCodeAt(tokPos);
        <span class="keyword">if</span> (ch2 &gt;= <span class="number">48</span> &amp;&amp; ch2 &lt;= <span class="number">55</span>) {    <span class="comment">// 0-7</span>
            shift = <span class="number">1</span>;
            ret = ret * <span class="number">8</span> + ch2 - <span class="number">48</span>;

            <span class="keyword">if</span> (ch &lt; <span class="number">52</span>) { <span class="comment">// '3' because value must be less than 255 overall -&gt; 377 in octal</span>
                <span class="keyword">var</span> ch3 = input.charCodeAt(tokPos+<span class="number">1</span>);
                <span class="keyword">if</span> (ch3 &gt;= <span class="number">48</span> &amp;&amp; ch3 &lt;= <span class="number">55</span>) {    <span class="comment">// 0-7</span>
                    shift = <span class="number">2</span>;
                    ret = ret * <span class="number">8</span> + ch3 - <span class="number">48</span>;
                }
            }
        }
        <span class="keyword">if</span> (ret !== <span class="number">0</span>) {
            <span class="keyword">if</span> (strict) raise(tokPos - <span class="number">2</span>, <span class="string">'Octal literal in strict mode'</span>);
            tokPos += shift;
        }
        <span class="keyword">return</span> ret;
    }

    <span class="keyword">var</span> rs_str = <span class="string">''</span>;</pre></div>
        
      
        
        <p>Used to read character escape sequences (&#39;\x&#39;, &#39;\u&#39;, &#39;\U&#39;).</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">readHexChar</span><span class="params">(len)</span> {</span>
        <span class="keyword">var</span> n = readInt16(len);
        <span class="keyword">if</span> (n === <span class="literal">null</span>) raise(tokStart, <span class="string">'Bad character escape sequence'</span>);
        <span class="keyword">return</span> n;
    }</pre></div>
        
      
        
        <p>Read escaped chars in strings
<a href="http://jsperf.com/readstring/4">http://jsperf.com/readstring/4</a></p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">readString_Esc</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> ch = input.charCodeAt(++tokPos);
        ++tokPos;

        <span class="keyword">switch</span>(ch) {
            <span class="keyword">case</span> <span class="number">110</span>: rs_str+=<span class="string">'\n'</span>; <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="number">114</span>: rs_str+=<span class="string">'\r'</span>; <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="number">120</span>: rs_str+=String.fromCharCode(readHexChar(<span class="number">2</span>)); <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="number">117</span>: rs_str+=String.fromCharCode(readHexChar(<span class="number">4</span>)); <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="number">85</span>: rs_str+=String.fromCharCode(readHexChar(<span class="number">8</span>)); <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="number">116</span>: rs_str+=<span class="string">'\t'</span>; <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="number">98</span>: rs_str+=<span class="string">'\b'</span>; <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="number">118</span>: rs_str+=<span class="string">'\x0b'</span>; <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="number">102</span>: rs_str+=<span class="string">'\f'</span>; <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="number">13</span>:
                <span class="keyword">if</span> (input.charCodeAt(tokPos) === <span class="number">10</span>) ++tokPos;
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="number">10</span>:
                <span class="keyword">break</span>;
            <span class="keyword">default</span>:
                <span class="keyword">if</span> (ch &gt;= <span class="number">48</span> &amp; ch &lt;= <span class="number">55</span>) { <span class="comment">// 0-7 -&gt; possible octal</span>
                    ch = readOctalLiteral(ch);
                }
                rs_str+=String.fromCharCode(ch);
        }
    }</pre></div>
        
      
        
        <p>Read a string ending with a quote - either &#39; or &quot;</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">readString</span><span class="params">(quote)</span> {</span>
        ++tokPos;
        rs_str=<span class="string">''</span>;

        <span class="keyword">var</span> start = tokPos;
        <span class="keyword">var</span> lastEsc = tokPos;
        <span class="keyword">var</span> ch = <span class="number">0</span>;

        <span class="keyword">while</span> (tokPos &lt; inputLen) {
            ch = input.charCodeAt(tokPos);

            <span class="keyword">if</span> (ch === quote) {
                <span class="keyword">if</span> (lastEsc === start) {
                    rs_str = input.substring(lastEsc,tokPos);
                } <span class="keyword">else</span> {
                    <span class="keyword">if</span> (lastEsc !== tokPos) {
                        rs_str+=input.substring(lastEsc,tokPos);
                    }
                }
                ++tokPos;
                tokRegexpAllowed = <span class="literal">false</span>;
                finishToken(_string, rs_str);
                <span class="keyword">return</span>;

            } <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="number">92</span>) { <span class="comment">// '\'</span>
                <span class="keyword">if</span> (lastEsc !== tokPos) {
                    rs_str+=input.substring(lastEsc,tokPos);
                }
                readString_Esc();
                lastEsc = tokPos;

            } <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="number">13</span> || ch === <span class="number">10</span> || ch === <span class="number">8232</span> || ch === <span class="number">8329</span>) {
                raise(tokStart, <span class="string">'Unterminated string constant'</span>);
                <span class="keyword">break</span>;
            } <span class="keyword">else</span> {
                ++tokPos;
            }
        }
        <span class="keyword">if</span> (tokPos &gt;= inputLen) {
            raise(tokStart, <span class="string">'Unterminated string constant'</span>);
        }
    }</pre></div>
        
      
        
        <p>Read the mod characters which may immediately follow a RegExp
&#39;g&#39;, &#39;\u0067&#39;, &#39;i&#39;, &#39;\u0069&#39;, &#39;m&#39;, &#39;\u006d&#39;, &#39;\u006D&#39;</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">readWord_regexpMods</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> start = tokPos;
        <span class="keyword">var</span> ch = input.charCodeAt(tokPos);
        <span class="keyword">var</span> flags = <span class="number">0</span>; <span class="comment">// g = 1, i = 2, m = 4</span>
        <span class="keyword">var</span> mods = <span class="string">''</span>;

        <span class="keyword">for</span> (;tokPos&lt;inputLen;) {
            <span class="keyword">if</span> (ch === <span class="number">103</span> &amp;&amp; (flags &amp; <span class="number">1</span>) === <span class="number">0</span>) {
                flags |= <span class="number">1</span>;
                mods += <span class="string">'g'</span>;
                ++tokPos;
            } <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="number">105</span> &amp;&amp; (flags &amp; <span class="number">2</span>) === <span class="number">0</span>) {
                flags |= <span class="number">2</span>;
                mods += <span class="string">'i'</span>;
                ++tokPos;
            } <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="number">109</span> &amp;&amp; (flags &amp; <span class="number">4</span>) === <span class="number">0</span>) {
                flags |= <span class="number">4</span>;
                mods += <span class="string">'m'</span>;
                ++tokPos;
            } <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="number">92</span>) { <span class="comment">// \u006[79Dd]</span>
                <span class="keyword">if</span> (
                    input.charCodeAt(tokPos+<span class="number">1</span>) === <span class="number">117</span> &amp;&amp;
                    input.charCodeAt(tokPos+<span class="number">2</span>) === <span class="number">48</span> &amp;&amp;
                    input.charCodeAt(tokPos+<span class="number">3</span>) === <span class="number">48</span> &amp;&amp;
                    input.charCodeAt(tokPos+<span class="number">4</span>) === <span class="number">54</span>
                    ) {
                    ch = input.charCodeAt(tokPos+<span class="number">5</span>);
                    <span class="keyword">if</span> (ch === <span class="number">55</span> &amp;&amp; (flags &amp; <span class="number">1</span>) === <span class="number">0</span>) {
                        flags |= <span class="number">1</span>;
                        mods += <span class="string">'g'</span>;
                        tokPos += <span class="number">6</span>;
                    } <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="number">57</span> &amp;&amp; (flags &amp; <span class="number">2</span>) === <span class="number">0</span>) {
                        flags |= <span class="number">2</span>;
                        mods += <span class="string">'i'</span>;
                        tokPos += <span class="number">6</span>;
                    } <span class="keyword">else</span> <span class="keyword">if</span> ((ch === <span class="number">68</span> || ch === <span class="number">100</span>) &amp;&amp; (flags &amp; <span class="number">4</span>) === <span class="number">0</span>) {
                        flags |= <span class="number">4</span>;
                        mods += <span class="string">'m'</span>;
                        tokPos += <span class="number">6</span>;
                    } <span class="keyword">else</span> {
                        readHexChar(<span class="number">4</span>);
                        raise(start, <span class="string">'Invalid regexp flag'</span>);
                    }
                } <span class="keyword">else</span> {
                    readHexChar(<span class="number">4</span>);
                    raise(start, <span class="string">'Invalid regexp flag'</span>);
                }
            } <span class="keyword">else</span> <span class="keyword">if</span> (isIdentifierChar[ch] === <span class="literal">true</span>) {
                raise(start, <span class="string">'Invalid regexp flag'</span>);
            } <span class="keyword">else</span> {
                <span class="keyword">break</span>;
            }
            ch = input.charCodeAt(tokPos);
        }

        <span class="keyword">return</span> mods;
    }</pre></div>
        
      
        
        <p>Slow function to build strings character by character.  Called
only when the quick function hits an escape char
<a href="http://jsperf.com/readword/3">http://jsperf.com/readword/3</a></p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">readWord_Esc</span><span class="params">(word, identifierFn)</span> {</span>
        <span class="keyword">for</span> (;tokPos&lt;inputLen;) {
            <span class="keyword">var</span> ch = input.charCodeAt(tokPos);
            <span class="keyword">if</span> (identifierFn[ch] === <span class="literal">true</span>) {
                word += input.charAt(tokPos);
                ++tokPos;
            } <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="number">92</span>) { <span class="comment">// "\"</span>
                <span class="keyword">if</span> (input.charCodeAt(++tokPos) !== <span class="number">117</span>) <span class="comment">//"u"</span>
                    raise(tokPos, <span class="string">'Expecting Unicode escape sequence \\uXXXX'</span>);
                ++tokPos;
                <span class="keyword">var</span> esc = readHexChar(<span class="number">4</span>);
                <span class="keyword">var</span> escStr = String.fromCharCode(esc);
                <span class="keyword">if</span> (escStr === <span class="string">''</span>) {
                    raise(tokPos - <span class="number">1</span>, <span class="string">'Invalid Unicode escape'</span>);
                } <span class="keyword">else</span> <span class="keyword">if</span> (identifierFn[esc] !== <span class="literal">true</span>) {
                    raise(tokPos - <span class="number">4</span>, <span class="string">'Invalid Unicode escape'</span>);
                } <span class="keyword">else</span> {
                    word += escStr;
                }
            } <span class="keyword">else</span> {
                <span class="keyword">break</span>;
            }
        }
        <span class="keyword">return</span> word;
    }</pre></div>
        
      
        
        <p>Read characters until one&#39;s not an allowed identifier char</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">readWord_simple</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> start = tokPos, ch = <span class="number">0</span>;
        ++tokPos;
        <span class="keyword">for</span> (;tokPos&lt;inputLen;) {
            ch = input.charCodeAt(tokPos);
            <span class="keyword">if</span> (isIdentifierChar[ch]===<span class="literal">true</span>) ++tokPos;
            <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="number">92</span>)
                <span class="keyword">return</span> readWord_Esc(input.substring(start, tokPos), isIdentifierChar);
            <span class="keyword">else</span> <span class="keyword">break</span>;
        }
        <span class="keyword">return</span> input.substring(start, tokPos);
    }</pre></div>
        
      
        
        <p>Read an identifier or keyword token. Will check for strict reserved
words when necessary.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">readWord</span><span class="params">()</span> {</span>
        tokRegexpAllowed = <span class="literal">false</span>;

        <span class="keyword">var</span> word = readWord_simple();
        <span class="keyword">if</span> (tokPos - tokStart &gt; <span class="number">1</span>) {
            tokType = isKeyword(word);
            <span class="keyword">if</span> (strict &amp;&amp; tokType === _name &amp;&amp; isStrictReservedWord(word)) {
                raise(tokStart, <span class="string">'The keyword \''</span> + word + <span class="string">'\' is reserved'</span>);
            }
        } <span class="keyword">else</span> {
            tokType = _name;
        }
        finishToken(tokType, word);
    }</pre></div>
        
      
        
        <p>As above, read an identifier or keyword token. Will check for
strict reserved words when necessary. Also checks for ECMAScript
3 / 5 reserved words.
Replaces readWord depending on parse options.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">readWord_checkReserved</span><span class="params">()</span> {</span>
        tokRegexpAllowed = <span class="literal">false</span>;

        <span class="keyword">var</span> word = readWord_n();
        <span class="keyword">if</span> (word.length &gt; <span class="number">1</span>) {
            tokType = isKeyword(word);
            <span class="keyword">if</span> (tokType === _name) {
                <span class="keyword">if</span> ((options.ecmaVersion === <span class="number">3</span> ? isReservedWord3 : isReservedWord5)(word))
                    raise(tokStart, <span class="string">'The keyword \''</span> + word + <span class="string">'\' is reserved'</span>);
                <span class="keyword">else</span> <span class="keyword">if</span> (strict &amp;&amp; isStrictReservedWord(word))
                    raise(tokStart, <span class="string">'The keyword \''</span> + word + <span class="string">'\' is reserved'</span>);
            }
        } <span class="keyword">else</span> {
            tokType = _name;
        }
        finishToken(tokType, word);
    }</pre></div>
        
      
        
        <h2>Parser</h2>
<p>A recursive descent parser operates by defining functions for all
syntactic elements, and recursively calling those, each function
advancing the input stream and returning an AST node. Precedence
of constructs (for example, the fact that <code>!x[1]</code> means <code>!(x[1])</code>
instead of <code>(!x)[1]</code> is handled by the fact that the parser
function that parses unary prefix operators is called first, and
in turn calls the function that parses <code>[]</code> subscripts — that
way, it&#39;ll receive the node for <code>x[1]</code> already parsed, and wraps
<em>that</em> in the unary operator node.</p>
<p>Overture uses an <a href="http://en.wikipedia.org/wiki/Operator-precedence_parser">operator precedence parser</a> to handle binary
operator precedence, because it is much more compact than using
the technique outlined above, which uses different, nesting
functions to specify precedence, for all of the ten binary
precedence levels that JavaScript defines.</p>
<p>Continue to the next token.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">next</span><span class="params">()</span> {</span>
        lastEnd = tokEnd;
        readToken();
    }</pre></div>
        
      
        
        <p>Enter strict mode. Re-reads the next token to please pedantic
tests (&quot;use strict&quot;; 010; -- should fail).</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">setStrict</span><span class="params">(strct)</span> {</span>
        strict = strct;
        tokPos = lastEnd;
        skipSpace();
        readToken();
    }</pre></div>
        
      
        
        <p>Test whether a statement node is the string literal <code>&quot;use strict&quot;</code>.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">isUseStrict</span><span class="params">(stmt)</span> {</span>
        <span class="keyword">return</span> options.ecmaVersion &gt;= <span class="number">5</span> &amp;&amp; stmt <span class="keyword">instanceof</span> ExpressionStatement &amp;&amp;
            stmt.expression <span class="keyword">instanceof</span> Literal_string &amp;&amp; stmt.expression.value === <span class="string">'use strict'</span>;
    }</pre></div>
        
      
        
        <p>Predicate that tests whether the next token is of the given
type, and if yes, consumes it as a side effect.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">eat</span><span class="params">(type)</span> {</span>
        <span class="keyword">if</span> (tokType === type) {
            next();
            <span class="keyword">return</span> <span class="literal">true</span>;
        }
        <span class="keyword">return</span> <span class="literal">false</span>;
    }</pre></div>
        
      
        
        <p>Tests to see if a semicolon can be inserted at the current position.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">cannotInsertSemicolon</span><span class="params">()</span> {</span>
        <span class="keyword">return</span> tokType !== _eof &amp;&amp; tokType !== _braceR &amp;&amp; !newline.test(input.substring(lastEnd, tokStart));
    }

    <span class="function"><span class="keyword">function</span> <span class="title">not_semicolon</span><span class="params">()</span> {</span>
        <span class="keyword">if</span> (tokType === _semi) {
            next();
            <span class="keyword">return</span> <span class="literal">false</span>;
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> tokType !== _eof &amp;&amp; tokType !== _braceR &amp;&amp; !newline.test(input.substring(lastEnd, tokStart));
        }
    }

    <span class="function"><span class="keyword">function</span> <span class="title">semicolon</span><span class="params">()</span> {</span>
        <span class="keyword">if</span> (not_semicolon()) unexpected();
    }</pre></div>
        
      
        
        <p>Expect a token of a given type. If found, consume it, otherwise,
raise an unexpected token error.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">expect</span><span class="params">(type)</span> {</span>
        <span class="keyword">if</span> (tokType === type) next();
        <span class="keyword">else</span> unexpected();
    }</pre></div>
        
      
        
        <p>Raise an unexpected token error.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">unexpected</span><span class="params">()</span> {</span>
        raise(tokStart, <span class="string">'Unexpected token'</span>);
    }</pre></div>
        
      
        
        <p>Verify that a node is an lval — something that can be assigned
to.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">checkLVal</span><span class="params">(expr)</span> {</span>
        <span class="keyword">if</span> (expr <span class="keyword">instanceof</span> MemberExpression_dot || expr <span class="keyword">instanceof</span> MemberExpression_bracketL) {
            <span class="keyword">return</span>;
        } <span class="keyword">else</span> <span class="keyword">if</span> (expr <span class="keyword">instanceof</span> Identifier) {
            <span class="keyword">if</span> (strict &amp;&amp; isStrictBadIdWord(expr.name))
                raise(tokPos, <span class="string">'Assigning to '</span> + expr.name + <span class="string">' in strict mode'</span>);
        } <span class="keyword">else</span> {
            raise(tokPos, <span class="string">'Assigning to rvalue'</span>);
        }
    }</pre></div>
        
      
        
        <h3>Statement parsing</h3>
<p>Parse a program. Initializes the parser, reads any number of
statements, and wraps them in a Program node.    Optionally takes a
<code>program</code> argument.    If present, the statements will be appended
to its body instead of creating a new node.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parseTopLevel</span><span class="params">(program)</span> {</span>
        initTokenState();
        lastEnd = tokPos;
        inFunction = strict = <span class="literal">null</span>;
        labels = [];
        readToken();

        <span class="keyword">var</span> node = program || <span class="keyword">new</span> Program();
        <span class="keyword">var</span> stmt = <span class="literal">null</span>;
        <span class="keyword">if</span> (tokType !== _eof) {
                stmt = parseStatement();
                node.body.push(stmt);
                <span class="keyword">if</span> (isUseStrict(stmt)) setStrict(<span class="literal">true</span>);

                <span class="keyword">while</span>(tokType !== _eof) {
                    stmt = parseStatement();
                    node.body.push(stmt);
                }
        }
        <span class="keyword">return</span> node;
    }

    <span class="keyword">var</span> str_loop = <span class="keyword">new</span> String(<span class="string">'loop'</span>);
    <span class="keyword">var</span> str_switch = <span class="keyword">new</span> String(<span class="string">'switch'</span>);

    <span class="keyword">var</span> loopLabel = {kind: str_loop};
    <span class="keyword">var</span> switchLabel = {kind: str_switch};</pre></div>
        
      
        
        <p>Verifies that there is an actual destination to break or
continue to.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">check_label_exists</span><span class="params">(label,isBreak,starttype)</span> {</span>
        <span class="keyword">var</span> i=<span class="number">0</span>,leni = labels.length;

        <span class="keyword">for</span> (; i &lt; leni; ++i) {
            <span class="keyword">var</span> lab = labels[i];
            <span class="keyword">if</span> (label === <span class="literal">null</span> || lab.name === label.name) {
                <span class="keyword">if</span> (lab.kind != <span class="literal">null</span> &amp;&amp; (isBreak || lab.kind === str_loop)) <span class="keyword">break</span>;
                <span class="keyword">if</span> (isBreak) <span class="keyword">break</span>;
            }
        }
        <span class="keyword">if</span> (i === leni) raise(tokPos, <span class="string">'Unsyntactic '</span> + starttype.keyword);
    }</pre></div>
        
      
        
        <p>Parse &#39;break&#39; either from loop or switch</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parse_BreakStatement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> starttype = tokType, node = <span class="keyword">new</span> BreakStatement();
        next();

        <span class="keyword">if</span> (not_semicolon()) {
            <span class="keyword">if</span> (tokType !== _name) unexpected();
            <span class="keyword">else</span> {
                node.label = parse_Identifier();
                semicolon();
            }
        }
        check_label_exists(node.label, <span class="literal">true</span>, starttype);
        <span class="keyword">return</span> node;
    }</pre></div>
        
      
        
        <p>Parse &#39;continue&#39; either in loop</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parse_ContinueStatement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> starttype = tokType, node = <span class="keyword">new</span> ContinueStatement();
        next();

        <span class="keyword">if</span> (not_semicolon()) {
            <span class="keyword">if</span> (tokType !== _name) unexpected();
            <span class="keyword">else</span> {
                node.label = parse_Identifier();
                semicolon();
            }
        }
        check_label_exists(node.label, <span class="literal">false</span>, starttype);
        <span class="keyword">return</span> node;
    }</pre></div>
        
      
        
        <p>Parse &#39;debugger&#39;</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parse_DebuggerStatement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> node = <span class="keyword">new</span> DebuggerStatement();
        next();
        semicolon();
        <span class="keyword">return</span> node;
    }</pre></div>
        
      
        
        <p>Parse &#39;do { } while()&#39;</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parse_DoWhileStatement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> node = <span class="keyword">new</span> DoWhileStatement();
        next();
        labels.push(loopLabel);
        node.body = parseStatement();
        labels.pop();
        expect(_<span class="keyword">while</span>);
        node.test = parseParenExpression();
        semicolon();
        <span class="keyword">return</span> node;
    }</pre></div>
        
      
        
        <p>Parse &#39;for (;;) {}&#39; and &#39;for ( in ) {}&#39;
Disambiguating between a <code>for</code> and a <code>for</code>/<code>in</code> loop is
non-trivial. Basically, we have to parse the init <code>var</code>
statement or expression, disallowing the <code>in</code> operator (see
the second parameter to <code>parseExpression</code>), and then check
whether the next token is <code>in</code>. When there is no init part
(semicolon immediately after the opening parenthesis), it is
a regular <code>for</code> loop.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parseStatement_for</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> init = <span class="literal">null</span>;
        <span class="keyword">var</span> node = <span class="literal">null</span>;
        next();
        labels.push(loopLabel);
        expect(_parenL);
        <span class="keyword">if</span> (tokType === _semi) {
            node = parse_ForStatement();
        } <span class="keyword">else</span> <span class="keyword">if</span> (tokType === _<span class="keyword">var</span>) {
            next();
            init = parseVar(<span class="literal">true</span>);
            <span class="keyword">if</span> (init.declarations.length === <span class="number">1</span> &amp;&amp; eat(_<span class="keyword">in</span>) === <span class="literal">true</span>) {
                node = parse_ForInStatement();
                node.left = init;
            } <span class="keyword">else</span> {
                node = parse_ForStatement();
                node.init = init;
            }
        } <span class="keyword">else</span> {
            init = parseExpression(<span class="literal">true</span>);
            <span class="keyword">if</span> (eat(_<span class="keyword">in</span>) === <span class="literal">true</span>) {
                checkLVal(init);
                node = parse_ForInStatement();
                node.left = init;
            } <span class="keyword">else</span> {
                node = parse_ForStatement();
                node.init = init;
            }
        }
        labels.pop();
        <span class="keyword">return</span> node;
    }</pre></div>
        
      
        
        <p>Parse &#39;function&#39;</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parse_Function</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> node = <span class="keyword">new</span> FunctionDeclaration();
        next();
        <span class="keyword">if</span> (tokType !== _name) unexpected();
        <span class="keyword">return</span> parseFunction(node);
    }</pre></div>
        
      
        
        <p>Parse &#39;if() {}&#39;</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parse_IfStatement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> node = <span class="keyword">new</span> IfStatement();
        next();
        node.test = parseParenExpression();
        node.consequent = parseStatement();
        <span class="keyword">if</span> (eat(_<span class="keyword">else</span>) === <span class="literal">true</span>) {
            node.alternate = parseStatement();
        }
        <span class="keyword">return</span> node;
    }</pre></div>
        
      
        
        <p>Parse &#39;return&#39;
In <code>return</code> (and <code>break</code>/<code>continue</code>), the keywords with
optional arguments, we eagerly look for a semicolon or the
possibility to insert one.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parse_ReturnStatement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> node = <span class="keyword">new</span> ReturnStatement();
        <span class="keyword">if</span> (inFunction) {
            next();
            <span class="keyword">if</span> (not_semicolon()) {
                node.argument = parseExpression(<span class="literal">false</span>);
                semicolon();
            }
            <span class="keyword">return</span> node;
        } <span class="keyword">else</span> {
            raise(tokStart, <span class="string">'\'return\' outside of function'</span>);
        }
    }</pre></div>
        
      
        
        <p>Parse &#39;switch() {<case:>* <default:>?}&#39;
Statements under must be grouped (by label) in SwitchCase
nodes. <code>cur</code> is used to keep the node that we are currently
adding statements to.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parse_SwitchStatement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> node = <span class="keyword">new</span> SwitchStatement();
        <span class="keyword">var</span> cur = <span class="literal">null</span>, sawDefault = <span class="literal">false</span>;
        next();
        node.discriminant = parseParenExpression();
        expect(_braceL);
        labels.push(switchLabel);

        <span class="keyword">for</span> (;;) {
            <span class="keyword">if</span> (tokType === _braceR) {
                next();
                <span class="keyword">break</span>;

            } <span class="keyword">else</span> <span class="keyword">if</span> (tokType === _<span class="keyword">case</span>) {
                cur = <span class="keyword">new</span> SwitchCase();
                node.cases.push(cur);
                next();
                cur.test = parseExpression(<span class="literal">false</span>);
                expect(_colon);

            } <span class="keyword">else</span> <span class="keyword">if</span> (tokType === _<span class="keyword">default</span>) {
                <span class="keyword">if</span> (sawDefault) {
                    raise(lastStart, <span class="string">'Multiple default clauses'</span>);
                } <span class="keyword">else</span> {
                    sawDefault = <span class="literal">true</span>;
                    cur = <span class="keyword">new</span> SwitchCase();
                    node.cases.push(cur);
                    next();
                    expect(_colon);
                }

            } <span class="keyword">else</span> {
                <span class="keyword">if</span> (cur === <span class="literal">null</span>) unexpected();
                cur.consequent.push(parseStatement());
            }
        }
        labels.pop();
        <span class="keyword">return</span> node;
    }</pre></div>
        
      
        
        <p>Parse &#39;throw&#39;</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parse_ThrowStatement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> node = <span class="keyword">new</span> ThrowStatement();
        next();
        <span class="keyword">if</span> (newline.test(input.substring(lastEnd, tokStart)))
            raise(lastEnd, <span class="string">'Illegal newline after throw'</span>);
        node.argument = parseExpression(<span class="literal">false</span>);
        semicolon();
        <span class="keyword">return</span> node;
    }</pre></div>
        
      
        
        <p>Parse &#39;try {} catch() {}&#39;, &#39;try {} finally {}&#39;, &#39;try {} catch() {} finally {}&#39;</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parse_TryStatement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> node = <span class="keyword">new</span> TryStatement();
        next();
        node.block = parse_BlockStatement();

        <span class="keyword">if</span> (tokType === _<span class="keyword">catch</span>) {
            <span class="keyword">var</span> clause = <span class="keyword">new</span> CatchClause();
            next();
            expect(_parenL);
            clause.param = parse_Identifier();
            <span class="keyword">if</span> (strict &amp;&amp; isStrictBadIdWord(clause.param.name))
                raise(tokPos, <span class="string">'Binding '</span> + clause.param.name + <span class="string">' in strict mode'</span>);
            expect(_parenR);
            clause.body = parse_BlockStatement();
            node.handler = clause;
        }

        <span class="keyword">if</span> (eat(_<span class="keyword">finally</span>) === <span class="literal">true</span>) {
            node.finalizer = parse_BlockStatement();
        }

        <span class="keyword">if</span> (node.handler === <span class="literal">null</span> &amp;&amp; node.finalizer === <span class="literal">null</span>)
            raise(tokPos, <span class="string">'Missing catch or finally clause'</span>);

        <span class="keyword">return</span> node;
    }</pre></div>
        
      
        
        <p>Parse &#39;var&#39;</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parseStatement_var</span><span class="params">()</span> {</span>
        next();
        <span class="keyword">var</span> node = parseVar();
        semicolon();
        <span class="keyword">return</span> node;
    }</pre></div>
        
      
        
        <p>Parse &#39;while() {}&#39;</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parse_WhileStatement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> node = <span class="keyword">new</span> WhileStatement();
        next();
        node.test = parseParenExpression();
        labels.push(loopLabel);
        node.body = parseStatement();
        labels.pop();
        <span class="keyword">return</span> node;
    }</pre></div>
        
      
        
        <p>Parse &#39;with () {}&#39;</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parse_WithStatement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> node = <span class="keyword">new</span> WithStatement();
        <span class="keyword">if</span> (strict) raise(tokStart, <span class="string">'\'with\' in strict mode'</span>);
        next();
        node.object = parseParenExpression();
        node.body = parseStatement();
        <span class="keyword">return</span> node;
    }</pre></div>
        
      
        
        <p>Parse an empty statement, i.e. a solitary semicolon</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parse_EmptyStatement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> node = <span class="keyword">new</span> EmptyStatement();
        next();
        <span class="keyword">return</span> node;
    }</pre></div>
        
      
        
        <p>If the statement does not start with a statement keyword or a
brace, it&#39;s an ExpressionStatement or LabeledStatement. We
simply start parsing an expression, and afterwards, if the
next token is a colon and the expression was a simple
Identifier node, we switch to interpreting it as a label.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parse_maybeLabeledStatement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> starttype = tokType, i, leni, node = <span class="literal">null</span>;
        <span class="keyword">var</span> maybeName = tokVal, expr = parseExpression(<span class="literal">false</span>);
        <span class="keyword">if</span> (starttype === _name &amp;&amp; expr <span class="keyword">instanceof</span> Identifier &amp;&amp; eat(_colon) === <span class="literal">true</span>) {
            node = <span class="keyword">new</span> LabeledStatement();
            <span class="keyword">for</span> (i = <span class="number">0</span>, leni = labels.length; i &lt; leni; ++i)
                <span class="keyword">if</span> (labels[i].name === maybeName) raise(tokPos, <span class="string">'Label \''</span> +maybeName+ <span class="string">'\' is already declared'</span>);
            <span class="keyword">var</span> label = <span class="keyword">new</span> Label(maybeName);
            <span class="keyword">switch</span>(tokType) {
                <span class="keyword">case</span> _<span class="keyword">do</span>:
                <span class="keyword">case</span> _<span class="keyword">for</span>:
                <span class="keyword">case</span> _<span class="keyword">while</span>:
                    label.kind = str_loop;
                    <span class="keyword">break</span>;
                <span class="keyword">case</span> _<span class="keyword">switch</span>:
                    label.kind = str_switch;
                    <span class="keyword">break</span>;
            }
            labels.push(label);
            node.body = parseStatement();
            labels.pop();
            node.label = expr;
        } <span class="keyword">else</span> {
            node = <span class="keyword">new</span> ExpressionStatement();
            node.expression = expr;
            semicolon();
        }
        <span class="keyword">return</span> node;

    }

    <span class="function"><span class="keyword">function</span> <span class="title">parse_ExpressionStatement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> node = <span class="keyword">new</span> ExpressionStatement();
        node.expression = parseExpression(<span class="literal">false</span>);
        semicolon();
        <span class="keyword">return</span> node;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parseStatement_default</span><span class="params">()</span> {</span>
        <span class="keyword">if</span> (tokType === _name) {
            <span class="keyword">return</span> parse_maybeLabeledStatement();
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> parse_ExpressionStatement();
        }
    }</pre></div>
        
      
        
        <p>Most types of statements are recognized by the keyword they
start with. Many are trivial to parse, some require a bit of
complexity.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parseStatement</span><span class="params">()</span> {</span>
        <span class="keyword">switch</span> (tokType) {
            <span class="keyword">case</span> _<span class="keyword">break</span>: <span class="keyword">return</span> parse_BreakStatement();
            <span class="keyword">case</span> _<span class="keyword">continue</span>: <span class="keyword">return</span> parse_ContinueStatement();
            <span class="keyword">case</span> _debugger: <span class="keyword">return</span> parse_DebuggerStatement();
            <span class="keyword">case</span> _<span class="keyword">do</span>: <span class="keyword">return</span> parse_DoWhileStatement();
            <span class="keyword">case</span> _<span class="keyword">for</span>: <span class="keyword">return</span> parseStatement_for();
            <span class="keyword">case</span> _<span class="keyword">function</span>: <span class="keyword">return</span> parse_Function();
            <span class="keyword">case</span> _<span class="keyword">if</span>: <span class="keyword">return</span> parse_IfStatement();
            <span class="keyword">case</span> _<span class="keyword">return</span>: <span class="keyword">return</span> parse_ReturnStatement();
            <span class="keyword">case</span> _<span class="keyword">switch</span>: <span class="keyword">return</span> parse_SwitchStatement();
            <span class="keyword">case</span> _<span class="keyword">throw</span>: <span class="keyword">return</span> parse_ThrowStatement();
            <span class="keyword">case</span> _<span class="keyword">try</span>: <span class="keyword">return</span> parse_TryStatement();
            <span class="keyword">case</span> _<span class="keyword">var</span>: <span class="keyword">return</span> parseStatement_var();
            <span class="keyword">case</span> _<span class="keyword">while</span>: <span class="keyword">return</span> parse_WhileStatement();
            <span class="keyword">case</span> _<span class="keyword">with</span>: <span class="keyword">return</span> parse_WithStatement();
            <span class="keyword">case</span> _braceL: <span class="keyword">return</span> parse_BlockStatement();
            <span class="keyword">case</span> _semi: <span class="keyword">return</span> parse_EmptyStatement();

            <span class="keyword">case</span> _slash:
                readToken_forceRegexp();

            <span class="keyword">default</span>:
                <span class="keyword">return</span> parseStatement_default();
        }
    }</pre></div>
        
      
        
        <p>Used for constructs like <code>switch</code> and <code>if</code> that insist on
parentheses around their expression.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parseParenExpression</span><span class="params">()</span> {</span>
        expect(_parenL);
        <span class="keyword">var</span> val = parseExpression(<span class="literal">false</span>);
        expect(_parenR);
        <span class="keyword">return</span> val;
    }</pre></div>
        
      
        
        <p>Parse a semicolon-enclosed block of statements, handling <code>&quot;use
strict&quot;</code> declarations when <code>allowStrict</code> is true (used for
function bodies).</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parse_BlockStatement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> node = <span class="keyword">new</span> BlockStatement(), strict = <span class="literal">false</span>, oldStrict;
        expect(_braceL);
        <span class="keyword">if</span> (eat(_braceR) === <span class="literal">false</span>) {
            <span class="keyword">for</span>(;;) {
                <span class="keyword">var</span> stmt = parseStatement();
                node.body.push(stmt);
                <span class="keyword">if</span> (isUseStrict(stmt)) {
                    oldStrict = strict;
                    setStrict(strict = <span class="literal">true</span>);
                }
                <span class="keyword">if</span> (eat(_braceR) === <span class="literal">true</span>) {<span class="keyword">break</span>;}
            }
        }
        <span class="keyword">if</span> (strict &amp;&amp; !oldStrict) setStrict(<span class="literal">false</span>);
        <span class="keyword">return</span> node;
    }</pre></div>
        
      
        
        <p>Parse a regular <code>for</code> loop. The disambiguation code in
<code>parseStatement</code> will already have parsed the init statement or
expression.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parse_ForStatement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> node = <span class="keyword">new</span> ForStatement();
        expect(_semi);
        <span class="keyword">if</span> (tokType !== _semi) node.test = parseExpression(<span class="literal">false</span>);
        expect(_semi);
        <span class="keyword">if</span> (tokType !== _parenR) node.update = parseExpression(<span class="literal">false</span>);
        expect(_parenR);
        node.body = parseStatement();
        <span class="keyword">return</span> node;
    }</pre></div>
        
      
        
        <p>Parse a &#39;for ( in ) {}&#39; loop.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parse_ForInStatement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> node = <span class="keyword">new</span> ForInStatement();
        node.right = parseExpression(<span class="literal">false</span>);
        expect(_parenR);
        node.body = parseStatement();
        <span class="keyword">return</span> node;
    }</pre></div>
        
      
        
        <p>Parse a list of variable declarations.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parseVar</span><span class="params">(noIn)</span> {</span>
        <span class="keyword">var</span> node = <span class="keyword">new</span> VariableDeclaration();
        <span class="keyword">for</span> (;;) {
            <span class="keyword">var</span> decl = <span class="keyword">new</span> VariableDeclarator();
            decl.id = parse_Identifier();
            <span class="keyword">if</span> (strict &amp;&amp; isStrictBadIdWord(decl.id.name))
                raise(tokPos, <span class="string">'Binding '</span> + decl.id.name + <span class="string">' in strict mode'</span>);
            <span class="keyword">if</span> (eat(_eq) === <span class="literal">true</span>) {
                decl.init = parseMaybeAssign(noIn);
            }
            node.declarations.push(decl);
            <span class="keyword">if</span> (eat(_comma) === <span class="literal">false</span>) <span class="keyword">break</span>;
        }
        <span class="keyword">return</span> node;
    }</pre></div>
        
      
        
        <h3>Expression parsing</h3>
<p>These nest, from the most general expression type at the top to
&#39;atomic&#39;, nondivisible expression types at the bottom. Most of
the functions will simply let the function(s) below them parse,
and, <em>if</em> the syntactic construct they handle is present, wrap
the AST node that the inner parser gave them in another node.</p>
<p>Parse a full expression. The arguments are used to forbid comma
sequences (in argument lists, array literals, or object literals)
or the <code>in</code> operator (in for loops initalization expressions).</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parseExpression</span><span class="params">(noIn)</span> {</span>
        <span class="keyword">var</span> expr = parseMaybeAssign(noIn);
        <span class="keyword">if</span> (tokType === _comma) {
            <span class="keyword">var</span> node = <span class="keyword">new</span> SequenceExpression();
            node.expressions.push(expr);
            <span class="keyword">while</span> (eat(_comma) === <span class="literal">true</span>) {
                node.expressions.push(parseMaybeAssign(noIn));
            }
            <span class="keyword">return</span> node;
        }
        <span class="keyword">return</span> expr;
    }</pre></div>
        
      
        
        <p>Parse an assignment expression. This includes applications of
operators like <code>+=</code>.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parseMaybeAssign</span><span class="params">(noIn)</span> {</span>
        <span class="keyword">var</span> left = parseMaybeConditional(noIn);
        <span class="keyword">if</span> (tokType.isAssign) {
            <span class="keyword">var</span> node = <span class="keyword">new</span> AssignmentExpression();
            node.operator = tokVal;
            node.left = left;
            next();
            node.right = parseMaybeAssign(noIn);
            checkLVal(left);
            <span class="keyword">return</span> node;
        }
        <span class="keyword">return</span> left;
    }</pre></div>
        
      
        
        <p>Parse a ternary conditional (<code>?:</code>) operator.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parseMaybeConditional</span><span class="params">(noIn)</span> {</span>
        <span class="keyword">var</span> expr = parseExprOp(parseMaybeUnary(), _bin_minop, noIn);
        <span class="keyword">if</span> (eat(_question) === <span class="literal">true</span>) {
            <span class="keyword">var</span> node = <span class="keyword">new</span> ConditionalExpression();
            node.test = expr;
            node.consequent = parseMaybeAssign(<span class="literal">false</span>);
            expect(_colon);
            node.alternate = parseMaybeAssign(noIn);
            <span class="keyword">return</span> node;
        }
        <span class="keyword">return</span> expr;
    }</pre></div>
        
      
        
        <p>Start the precedence parser.</p>
<p>Parse binary operators with the operator precedence parsing
algorithm. <code>left</code> is the left-hand side of the operator.
<code>minPrec</code> provides context that allows the function to stop and
defer further parser to one of its callers when it encounters an
operator that has a lower precedence than the set it is parsing.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parseExprOp</span><span class="params">(left, minTokType, noIn)</span> {</span> <span class="comment">// what to do about this garbage producing noIn?</span>
        <span class="keyword">var</span> node = <span class="literal">null</span>;
        <span class="keyword">var</span> curTokType = tokType;

        <span class="keyword">if</span> (curTokType.precedence !== <span class="number">0</span> &amp;&amp; curTokType.precedence &gt; minTokType.precedence &amp;&amp; (!noIn || tokType !== _<span class="keyword">in</span>)) {

            <span class="keyword">if</span> (tokVal === LogicalOperator.AND || tokVal === LogicalOperator.OR) {
                node = <span class="keyword">new</span> LogicalExpression();
            } <span class="keyword">else</span> {
                node = <span class="keyword">new</span> BinaryExpression();
            }
            node.left = left;
            node.operator = tokVal;
            next();
            node.right = parseExprOp(parseMaybeUnary(), curTokType, noIn);
            <span class="keyword">return</span> parseExprOp(node, minTokType, noIn);
        }
        <span class="keyword">return</span> left;
    }</pre></div>
        
      
        
        <p>Parse unary operators, both prefix and postfix.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parseMaybeUnary</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> node = <span class="literal">null</span>;
        <span class="keyword">if</span> (tokType.prefix) {
            <span class="keyword">if</span> (tokType.isUpdate) {
                node = <span class="keyword">new</span> UpdateExpression();
                node.operator = tokVal;
                next();
                node.argument = parseMaybeUnary();
                checkLVal(node.argument);
            } <span class="keyword">else</span> {
                node = <span class="keyword">new</span> UnaryExpression();
                node.operator = tokVal;
                next();
                node.argument = parseMaybeUnary();
                <span class="keyword">if</span> (strict &amp;&amp; node.operator === <span class="string">'delete'</span> &amp;&amp;
                             node.argument <span class="keyword">instanceof</span> Identifier)
                raise(tokPos, <span class="string">'Deleting local variable in strict mode'</span>);
            }
        } <span class="keyword">else</span> {
            <span class="keyword">var</span> expr = parseExprSubscripts();
            <span class="keyword">while</span> (tokType.postfix &amp;&amp; cannotInsertSemicolon()) {
                node = <span class="keyword">new</span> UpdateExpression();
                node.operator = tokVal;
                node.prefix = <span class="literal">false</span>;
                node.argument = expr;
                checkLVal(expr);
                next();
                expr = node;
            }
            node = expr;
        }
        <span class="keyword">return</span> node;
    }</pre></div>
        
      
        
        <p>Parse call, dot, and <code>[]</code>-subscript expressions.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parseExprSubscripts</span><span class="params">()</span> {</span>
        <span class="keyword">return</span> parseSubscripts(parseExprAtom());
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parseSubscripts</span><span class="params">(base)</span> {</span>
        <span class="keyword">var</span> node = <span class="literal">null</span>;
        <span class="keyword">if</span> (eat(_dot) === <span class="literal">true</span>) {
            node = <span class="keyword">new</span> MemberExpression_dot(base);
            node.property = parse_Identifier_liberal();
            <span class="keyword">return</span> parseSubscripts(node);

        } <span class="keyword">else</span> <span class="keyword">if</span> (eat(_bracketL) === <span class="literal">true</span>) {
            node = <span class="keyword">new</span> MemberExpression_bracketL(base);
            node.property = parseExpression(<span class="literal">false</span>);
            expect(_bracketR);
            <span class="keyword">return</span> parseSubscripts(node);

        } <span class="keyword">else</span> <span class="keyword">if</span> (eat(_parenL) === <span class="literal">true</span>) {
            node = <span class="keyword">new</span> CallExpression(base);
            parse_ExpressionList(node.arguments);
            <span class="keyword">return</span> parseSubscripts(node);

        } <span class="keyword">else</span> <span class="keyword">return</span> base;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parseSubscripts_nocalls</span><span class="params">(base)</span> {</span>
        <span class="keyword">var</span> node = <span class="literal">null</span>;
        <span class="keyword">if</span> (eat(_dot) === <span class="literal">true</span>) {
            node = <span class="keyword">new</span> MemberExpression_dot(base);
            node.property = parse_Identifier_liberal();
            <span class="keyword">return</span> parseSubscripts_nocalls(node);

        } <span class="keyword">else</span> <span class="keyword">if</span> (eat(_bracketL) === <span class="literal">true</span>) {
            node = <span class="keyword">new</span> MemberExpression_bracketL(base);
            node.property = parseExpression(<span class="literal">false</span>);
            expect(_bracketR);
            <span class="keyword">return</span> parseSubscripts_nocalls(node);

        } <span class="keyword">else</span> <span class="keyword">return</span> base;
    }</pre></div>
        
      
        
        <p>Parse an atomic expression — either a single token that is an
expression, an expression started by a keyword like <code>function</code> or
<code>new</code>, or an expression wrapped in punctuation like <code>()</code>, <code>[]</code>,
or <code>{}</code>.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parse_ThisExpression</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> node = <span class="keyword">new</span> ThisExpression();
        next();
        <span class="keyword">return</span> node;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parse_Literal_Number</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> node = <span class="keyword">new</span> Literal_number();
        node.value = tokVal;
        next();
        <span class="keyword">return</span> node;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parse_Literal_String</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> node = <span class="keyword">new</span> Literal_string();
        node.value = tokVal;
        next();
        <span class="keyword">return</span> node;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parse_Literal_Regexp</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> node = <span class="keyword">new</span> Literal_regexp();
        node.value = tokVal;
        next();
        <span class="keyword">return</span> node;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parse_Literal_Null</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> node = <span class="keyword">new</span> Literal_null();
        next();
        <span class="keyword">return</span> node;
    }
    <span class="function"><span class="keyword">function</span> <span class="title">parse_Literal_True</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> node = <span class="keyword">new</span> Literal_true();
        next();
        <span class="keyword">return</span> node;
    }
    <span class="function"><span class="keyword">function</span> <span class="title">parse_Literal_False</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> node = <span class="keyword">new</span> Literal_false();
        next();
        <span class="keyword">return</span> node;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parseExprAtom_parenL</span><span class="params">()</span> {</span>
        next();
        <span class="keyword">var</span> val = parseExpression(<span class="literal">false</span>);
        expect(_parenR);
        <span class="keyword">return</span> val;
    }
    <span class="function"><span class="keyword">function</span> <span class="title">parse_ArrayExpression</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> node = <span class="keyword">new</span> ArrayExpression();
        next();
        parse_ArrayExpressionList(node.elements);
        <span class="keyword">return</span> node;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parse_FunctionExpression</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> node = <span class="keyword">new</span> FunctionExpression();
        next();
        <span class="keyword">return</span> parseFunction(node);
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parseExprAtom</span><span class="params">()</span> {</span>
        <span class="keyword">switch</span> (tokType) {
            <span class="keyword">case</span> _<span class="keyword">new</span>: <span class="keyword">return</span> parse_NewExpression();
            <span class="keyword">case</span> _num: <span class="keyword">return</span> parse_Literal_Number();
            <span class="keyword">case</span> _<span class="keyword">this</span>: <span class="keyword">return</span> parse_ThisExpression();
            <span class="keyword">case</span> _name: <span class="keyword">return</span> parse_Identifier();
            <span class="keyword">case</span> _<span class="literal">null</span>: <span class="keyword">return</span> parse_Literal_Null();
            <span class="keyword">case</span> _<span class="literal">true</span>: <span class="keyword">return</span> parse_Literal_True();
            <span class="keyword">case</span> _<span class="literal">false</span>: <span class="keyword">return</span> parse_Literal_False();
            <span class="keyword">case</span> _braceL: <span class="keyword">return</span> parse_ObjectExpression();
            <span class="keyword">case</span> _string: <span class="keyword">return</span> parse_Literal_String();
            <span class="keyword">case</span> _regexp: <span class="keyword">return</span> parse_Literal_Regexp();
            <span class="keyword">case</span> _parenL: <span class="keyword">return</span> parseExprAtom_parenL();
            <span class="keyword">case</span> _bracketL: <span class="keyword">return</span> parse_ArrayExpression();
            <span class="keyword">case</span> _<span class="keyword">function</span>: <span class="keyword">return</span> parse_FunctionExpression();

            <span class="keyword">default</span>:
                unexpected();
        }
    }</pre></div>
        
      
        
        <p>New&#39;s precedence is slightly tricky. It must allow its argument
to be a <code>[]</code> or dot subscript expression, but not a call — at
least, not without wrapping it in parentheses. Thus, it uses the</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parse_NewExpression</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> node = <span class="keyword">new</span> NewExpression();
        next();
        node.callee = parseSubscripts_nocalls(parseExprAtom(<span class="literal">false</span>));
        <span class="keyword">if</span> (eat(_parenL) === <span class="literal">true</span>) parse_ExpressionList(node.arguments);
        <span class="keyword">return</span> node;
    }</pre></div>
        
      
        
        <p>Parse an object literal.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parsePropertyName</span><span class="params">()</span> {</span>
        <span class="keyword">if</span> (tokType === _string || tokType === _num) {
            <span class="keyword">return</span> parseExprAtom();
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> parse_Identifier_liberal();
        }
    }</pre></div>
        
      
        
        <p>getters and setters are not allowed to clash — either with
each other or with an init property — and in strict mode,
init properties are also not allowed to be repeated.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parseGetterOrSetter</span><span class="params">(prop)</span> {</span>
        <span class="keyword">if</span> (options.ecmaVersion &gt;= <span class="number">5</span> &amp;&amp; prop.key <span class="keyword">instanceof</span> Identifier) {
            <span class="keyword">if</span> (prop.key.name === <span class="string">'get'</span>) {
                prop.kind = PropertyKind.get;
                prop.key = parsePropertyName();
                <span class="keyword">if</span> (tokType !== _parenL) unexpected();
                prop.value = parseFunction(<span class="keyword">new</span> FunctionExpression());
            } <span class="keyword">else</span> <span class="keyword">if</span> (prop.key.name === <span class="string">'set'</span>) {
                prop.kind = PropertyKind.set;
                prop.key = parsePropertyName();
                <span class="keyword">if</span> (tokType !== _parenL) unexpected();
                prop.value = parseFunction(<span class="keyword">new</span> FunctionExpression());
            } <span class="keyword">else</span> unexpected();
        } <span class="keyword">else</span> unexpected();
    }

    <span class="function"><span class="keyword">function</span> <span class="title">validateObjectProperties</span><span class="params">(props)</span> {</span>
        <span class="keyword">var</span> prop, other, i=<span class="number">0</span>, j=<span class="number">0</span>, len = props.length;

        <span class="keyword">for</span>(;j&lt;len;j++) {
            prop = props[j];
            <span class="keyword">if</span> (prop.key <span class="keyword">instanceof</span> Identifier) {
                <span class="keyword">for</span> (i=j+<span class="number">1</span>;i&lt;len;i++) {
                    other = props[i];
                    <span class="keyword">if</span> (other.key <span class="keyword">instanceof</span> Identifier &amp;&amp; other.key.name === prop.key.name) {
                        <span class="keyword">if</span> (
                            (prop.kind === other.kind &amp;&amp; (strict || prop.kind !== PropertyKind.init)) ||
                            (other.kind === PropertyKind.init &amp;&amp; prop.kind !== PropertyKind.init) ||
                            (prop.kind === PropertyKind.init &amp;&amp; other.kind !== PropertyKind.init)
                            ) {
                                raise(tokPos, <span class="string">'Redefinition of property'</span>);
                            }
                    }
                }
            }
        }
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parse_ObjectExpression</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> node = <span class="keyword">new</span> ObjectExpression();
        next();

        <span class="keyword">if</span> (eat(_braceR) === <span class="literal">false</span>) {
            <span class="keyword">for</span>(;;) {
                <span class="keyword">var</span> prop = <span class="keyword">new</span> ObjectExpressionProp();
                prop.key = parsePropertyName();

                <span class="keyword">if</span> (eat(_colon) === <span class="literal">true</span>) {
                    prop.value = parseMaybeAssign(<span class="literal">false</span>);
                    prop.kind = PropertyKind.init;
                } <span class="keyword">else</span> {
                    parseGetterOrSetter(prop);
                }

                node.properties.push(prop);
                <span class="keyword">if</span> (eat(_braceR) === <span class="literal">true</span>) <span class="keyword">break</span>;
                expect(_comma);
                <span class="keyword">if</span> (options.allowTrailingCommas &amp;&amp; eat(_braceR) === <span class="literal">true</span>) <span class="keyword">break</span>;
            }
        }
        validateObjectProperties(node.properties);
        <span class="keyword">return</span> node;
    }</pre></div>
        
      
        
        <p>Parse a function declaration or literal</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parseFunction</span><span class="params">(node)</span> {</span>
        <span class="keyword">if</span> (tokType === _name) node.id = parse_Identifier();

        expect(_parenL);

        <span class="keyword">if</span> (eat(_parenR) === <span class="literal">false</span>) {
            <span class="keyword">for</span>(;;) {
                node.params.push(parse_Identifier());
                <span class="keyword">if</span> (eat(_parenR) === <span class="literal">true</span>) {<span class="keyword">break</span>;}
                expect(_comma);
            }
        }</pre></div>
        
      
        
        <p>Start a new scope with regard to labels and the <code>inFunction</code>
flag (restore them to their old value afterwards).</p>

        
          <div class='highlight'><pre>        <span class="keyword">var</span> oldInFunc = inFunction, oldLabels = labels;
        inFunction = <span class="literal">true</span>; labels = [];
        node.body = parse_BlockStatement();
        inFunction = oldInFunc; labels = oldLabels;</pre></div>
        
      
        
        <p>If this is a strict mode function, verify that argument names
are not repeated, and it does not try to bind the words <code>eval</code>
or <code>arguments</code>.</p>

        
          <div class='highlight'><pre>        <span class="keyword">if</span> (strict || node.body.body.length &amp;&amp; isUseStrict(node.body.body[<span class="number">0</span>])) {
            <span class="keyword">for</span> (<span class="keyword">var</span> i = node.id ? -<span class="number">1</span> : <span class="number">0</span>, leni = node.params.length; i &lt; leni; ++i) {
                <span class="keyword">var</span> id = i &lt; <span class="number">0</span> ? node.id : node.params[i];
                <span class="keyword">if</span> (isStrictReservedWord(id.name) || isStrictBadIdWord(id.name))
                    raise(tokPos, <span class="string">'Defining \''</span> +id.name+ <span class="string">'\' in strict mode'</span>);
                <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; i; ++j) <span class="keyword">if</span> (id.name === node.params[j].name)
                    raise(tokPos, <span class="string">'Argument name clash in strict mode'</span>);
            }
        }

        <span class="keyword">return</span> node;
    }</pre></div>
        
      
        
        <p>Parses a comma-separated list of expressions, and returns them as
an array. <code>close</code> is the token type that ends the list, and
<code>allowEmpty</code> can be turned on to allow subsequent commas with
nothing in between them to be parsed as <code>null</code> (which is needed
for array literals).</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parse_ArrayExpressionList</span><span class="params">(list)</span> {</span>
        <span class="keyword">if</span> (eat(_bracketR) === <span class="literal">false</span>) {
            <span class="keyword">for</span>(;;) {
                <span class="keyword">if</span> (tokType === _comma) {
                    list.push(<span class="literal">null</span>);
                } <span class="keyword">else</span> {
                    list.push(parseMaybeAssign(<span class="literal">false</span>));
                }

                <span class="keyword">if</span> (eat(_bracketR) === <span class="literal">true</span>) <span class="keyword">return</span>;

                expect(_comma);

                <span class="keyword">if</span> (options.allowTrailingCommas &amp;&amp; eat(_bracketR) === <span class="literal">true</span>) <span class="keyword">return</span>;
            }
        }
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parse_ExpressionList</span><span class="params">(list)</span> {</span>
        <span class="keyword">if</span> (eat(_parenR) === <span class="literal">false</span>) {
            <span class="keyword">for</span>(;;) {
                list.push(parseMaybeAssign(<span class="literal">false</span>));
                <span class="keyword">if</span> (eat(_parenR) === <span class="literal">true</span>) {
                    <span class="keyword">return</span>;
                } <span class="keyword">else</span> {
                    expect(_comma);
                }
            }
        }
    }</pre></div>
        
      
        
        <p>Parse the next token as an identifier. If <code>liberal</code> is true (used
when parsing properties), it will also convert keywords into
identifiers.</p>

        
          <div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">parse_Identifier_liberal</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> node = <span class="keyword">new</span> Identifier();
        node.name = tokType === _name ? tokVal : (!options.forbidReserved &amp;&amp; tokType.keyword) || unexpected();
        next();
        <span class="keyword">return</span> node;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parse_Identifier</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> node = <span class="keyword">new</span> Identifier();
        <span class="keyword">if</span> (tokType === _name) {
            node.name = tokVal;
        } <span class="keyword">else</span> {
            unexpected();
        }
        next();
        <span class="keyword">return</span> node;
    }
});</pre></div>
        
      
      <div class="fleur">h</div>
    </div>
  </div>
</body>
</html>
